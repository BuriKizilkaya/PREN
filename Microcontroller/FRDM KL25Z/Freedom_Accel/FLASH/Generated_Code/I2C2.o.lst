   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"I2C2.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	24
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.bss.INT_I2C0__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  24              		.align	2
  27              	INT_I2C0__DEFAULT_RTOS_ISRPARAM:
  28 0000 00000000 		.space	4
  29              		.section	.text.I2C2_Interrupt,"ax",%progbits
  30              		.align	2
  31              		.global	I2C2_Interrupt
  32              		.code	16
  33              		.thumb_func
  35              	I2C2_Interrupt:
  36              	.LFB0:
  37              		.file 1 "../Generated_Code/I2C2.c"
   1:../Generated_Code/I2C2.c **** /** ###################################################################
   2:../Generated_Code/I2C2.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/I2C2.c **** **     Filename    : I2C2.c
   4:../Generated_Code/I2C2.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/I2C2.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/I2C2.c **** **     Component   : I2C_LDD
   7:../Generated_Code/I2C2.c **** **     Version     : Component 01.011, Driver 01.06, CPU db: 3.00.000
   8:../Generated_Code/I2C2.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/I2C2.c **** **     Date/Time   : 2012-12-05, 08:54, # CodeGen: 12
  10:../Generated_Code/I2C2.c **** **     Abstract    :
  11:../Generated_Code/I2C2.c **** **          This component encapsulates the internal I2C communication
  12:../Generated_Code/I2C2.c **** **          interface. The implementation of the interface is based
  13:../Generated_Code/I2C2.c **** **          on the Philips I2C-bus specification version 2.0.
  14:../Generated_Code/I2C2.c **** **          Interface features:
  15:../Generated_Code/I2C2.c **** **          MASTER mode
  16:../Generated_Code/I2C2.c **** **            - Multi master communication
  17:../Generated_Code/I2C2.c **** **            - The combined format of communication possible
  18:../Generated_Code/I2C2.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
  19:../Generated_Code/I2C2.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
  20:../Generated_Code/I2C2.c **** **            - Acknowledge polling provided
  21:../Generated_Code/I2C2.c **** **            - No wait state initiated when a slave device holds the SCL line low
  22:../Generated_Code/I2C2.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
  23:../Generated_Code/I2C2.c **** **            - Invalid start/stop condition detection provided
  24:../Generated_Code/I2C2.c **** **          SLAVE mode
  25:../Generated_Code/I2C2.c **** **            - 7-bit slave addressing
  26:../Generated_Code/I2C2.c **** **            - General call address detection provided
  27:../Generated_Code/I2C2.c **** **     Settings    :
  28:../Generated_Code/I2C2.c **** **          Component name                                 : I2C2
  29:../Generated_Code/I2C2.c **** **          I2C channel                                    : I2C0
  30:../Generated_Code/I2C2.c **** **          Interrupt service                              : Enabled
  31:../Generated_Code/I2C2.c **** **            Interrupt                                    : INT_I2C0
  32:../Generated_Code/I2C2.c **** **            Interrupt priority                           : medium priority
  33:../Generated_Code/I2C2.c **** **          Settings                                       : 
  34:../Generated_Code/I2C2.c **** **            Mode selection                               : MASTER
  35:../Generated_Code/I2C2.c **** **            MASTER mode                                  : Enabled
  36:../Generated_Code/I2C2.c **** **              Initialization                             : 
  37:../Generated_Code/I2C2.c **** **                Address mode                             : 7-bit addressing
  38:../Generated_Code/I2C2.c **** **                Target slave address init                : 1D
  39:../Generated_Code/I2C2.c **** **            SLAVE mode                                   : Disabled
  40:../Generated_Code/I2C2.c **** **            Pins                                         : 
  41:../Generated_Code/I2C2.c **** **              SDA pin                                    : 
  42:../Generated_Code/I2C2.c **** **                SDA pin                                  : PTE25/TPM0_CH1/I2C0_SDA
  43:../Generated_Code/I2C2.c **** **                SDA pin signal                           : I2C_SDA
  44:../Generated_Code/I2C2.c **** **              SCL pin                                    : 
  45:../Generated_Code/I2C2.c **** **                SCL pin                                  : PTE24/TPM0_CH0/I2C0_SCL
  46:../Generated_Code/I2C2.c **** **                SCL pin signal                           : I2C_SCL
  47:../Generated_Code/I2C2.c **** **              High drive select                          : Disabled
  48:../Generated_Code/I2C2.c **** **              Input Glitch filter                        : 0
  49:../Generated_Code/I2C2.c **** **            Internal frequency (multiplier factor)       : 20.97152 MHz
  50:../Generated_Code/I2C2.c **** **            Bits 0-2 of Frequency divider register       : 000
  51:../Generated_Code/I2C2.c **** **            Bits 3-5 of Frequency divider register       : 000
  52:../Generated_Code/I2C2.c **** **            SCL frequency                                : 1048.576 kHz
  53:../Generated_Code/I2C2.c **** **            SDA Hold                                     : 0.334 us
  54:../Generated_Code/I2C2.c **** **            SCL start Hold                               : 0.286 us
  55:../Generated_Code/I2C2.c **** **            SCL stop Hold                                : 0.525 us
  56:../Generated_Code/I2C2.c **** **            Control acknowledge bit                      : Disabled
  57:../Generated_Code/I2C2.c **** **            Low timeout                                  : Disabled
  58:../Generated_Code/I2C2.c **** **          Initialization                                 : 
  59:../Generated_Code/I2C2.c **** **            Enabled in init code                         : yes
  60:../Generated_Code/I2C2.c **** **            Auto initialization                          : no
  61:../Generated_Code/I2C2.c **** **            Event mask                                   : 
  62:../Generated_Code/I2C2.c **** **              OnMasterBlockSent                          : Enabled
  63:../Generated_Code/I2C2.c **** **              OnMasterBlockReceived                      : Enabled
  64:../Generated_Code/I2C2.c **** **              OnMasterByteReceived                       : Disabled
  65:../Generated_Code/I2C2.c **** **              OnSlaveBlockSent                           : Disabled
  66:../Generated_Code/I2C2.c **** **              OnSlaveBlockReceived                       : Disabled
  67:../Generated_Code/I2C2.c **** **              OnSlaveByteReceived                        : Disabled
  68:../Generated_Code/I2C2.c **** **              OnSlaveRxRequest                           : Disabled
  69:../Generated_Code/I2C2.c **** **              OnSlaveTxRequest                           : Disabled
  70:../Generated_Code/I2C2.c **** **              OnSlaveGeneralCallAddr                     : Disabled
  71:../Generated_Code/I2C2.c **** **              OnSlaveSmBusCallAddr                       : Disabled
  72:../Generated_Code/I2C2.c **** **              OnSlaveSmBusAlertResponse                  : Disabled
  73:../Generated_Code/I2C2.c **** **              OnError                                    : Enabled
  74:../Generated_Code/I2C2.c **** **              OnBusStopDetected                          : Disabled
  75:../Generated_Code/I2C2.c **** **          CPU clock/configuration selection              : 
  76:../Generated_Code/I2C2.c **** **            Clock configuration 0                        : This component enabled
  77:../Generated_Code/I2C2.c **** **            Clock configuration 1                        : This component disabled
  78:../Generated_Code/I2C2.c **** **            Clock configuration 2                        : This component disabled
  79:../Generated_Code/I2C2.c **** **            Clock configuration 3                        : This component disabled
  80:../Generated_Code/I2C2.c **** **            Clock configuration 4                        : This component disabled
  81:../Generated_Code/I2C2.c **** **            Clock configuration 5                        : This component disabled
  82:../Generated_Code/I2C2.c **** **            Clock configuration 6                        : This component disabled
  83:../Generated_Code/I2C2.c **** **            Clock configuration 7                        : This component disabled
  84:../Generated_Code/I2C2.c **** **     Contents    :
  85:../Generated_Code/I2C2.c **** **         Init               - LDD_TDeviceData* I2C2_Init(LDD_TUserData *UserDataPtr);
  86:../Generated_Code/I2C2.c **** **         Deinit             - void I2C2_Deinit(LDD_TDeviceData *DeviceDataPtr);
  87:../Generated_Code/I2C2.c **** **         MasterSendBlock    - LDD_TError I2C2_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD
  88:../Generated_Code/I2C2.c **** **         MasterReceiveBlock - LDD_TError I2C2_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, 
  89:../Generated_Code/I2C2.c **** **         SelectSlaveDevice  - LDD_TError I2C2_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr,..
  90:../Generated_Code/I2C2.c **** **         GetError           - LDD_TError I2C2_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TE
  91:../Generated_Code/I2C2.c **** **
  92:../Generated_Code/I2C2.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  93:../Generated_Code/I2C2.c **** **     
  94:../Generated_Code/I2C2.c **** **     http      : www.freescale.com
  95:../Generated_Code/I2C2.c **** **     mail      : support@freescale.com
  96:../Generated_Code/I2C2.c **** ** ###################################################################*/
  97:../Generated_Code/I2C2.c **** 
  98:../Generated_Code/I2C2.c **** /* MODULE I2C2. */
  99:../Generated_Code/I2C2.c **** 
 100:../Generated_Code/I2C2.c **** #include "Events.h"
 101:../Generated_Code/I2C2.c **** #include "I2C2.h"
 102:../Generated_Code/I2C2.c **** #include "PORT_PDD.h"
 103:../Generated_Code/I2C2.c **** #include "I2C_PDD.h"
 104:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} No RTOS includes */
 105:../Generated_Code/I2C2.c **** #include "IO_Map.h"
 106:../Generated_Code/I2C2.c **** 
 107:../Generated_Code/I2C2.c **** 
 108:../Generated_Code/I2C2.c **** /* SerFlag bits */
 109:../Generated_Code/I2C2.c **** #define MASTER_IN_PROGRES       0x01U  /* Communication is in progress (Master) */
 110:../Generated_Code/I2C2.c **** #define ADDR_COMPLETE           0x02U  /* 10-bit address transmission complete   */
 111:../Generated_Code/I2C2.c **** #define REP_ADDR_COMPLETE       0x04U  /* repeated address transmission complete */
 112:../Generated_Code/I2C2.c **** #define GENERAL_CALL            0x08U  /* General call flag */
 113:../Generated_Code/I2C2.c **** #define ADDR_10                 0x10U  /* 10-bit addr flag */
 114:../Generated_Code/I2C2.c **** #define ADDR_7                  0x20U  /* 7-bit addr flag */
 115:../Generated_Code/I2C2.c **** 
 116:../Generated_Code/I2C2.c **** typedef struct {
 117:../Generated_Code/I2C2.c ****   uint8_t SerFlag;                     /* Flags for serial communication */
 118:../Generated_Code/I2C2.c ****                                        /* Bits: 0 - Running int from TX */
 119:../Generated_Code/I2C2.c ****                                        /*       1 - 10-bit address transmission complete   */
 120:../Generated_Code/I2C2.c ****                                        /*       2 - repeated address transmission complete */
 121:../Generated_Code/I2C2.c ****                                        /*       3 - General Call flag */
 122:../Generated_Code/I2C2.c ****                                        /*       4 - 10-bit addr flag */
 123:../Generated_Code/I2C2.c ****                                        /*       5 - 7-bit addr flag */
 124:../Generated_Code/I2C2.c ****   LDD_I2C_TSendStop SendStop;          /* Enable/Disable generate send stop condition after transmi
 125:../Generated_Code/I2C2.c ****   LDD_I2C_TErrorMask ErrorMask;        /* Variable for errors mask value */
 126:../Generated_Code/I2C2.c ****   uint8_t SlaveAddr;                   /* Variable for Slave address */
 127:../Generated_Code/I2C2.c ****   uint8_t SlaveAddrHigh;               /* Variable for High byte of the Slave address (10-bit addre
 128:../Generated_Code/I2C2.c ****   LDD_I2C_TSize InpLenM;               /* The counter of input bufer's content */
 129:../Generated_Code/I2C2.c ****   uint8_t *InpPtrM;                    /* Pointer to input buffer for Master mode */
 130:../Generated_Code/I2C2.c ****   LDD_I2C_TSize OutLenM;               /* The counter of output bufer's content */
 131:../Generated_Code/I2C2.c ****   uint8_t *OutPtrM;                    /* Pointer to output buffer for Master mode */
 132:../Generated_Code/I2C2.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 133:../Generated_Code/I2C2.c **** } I2C2_TDeviceData;
 134:../Generated_Code/I2C2.c **** 
 135:../Generated_Code/I2C2.c **** typedef I2C2_TDeviceData *I2C2_TDeviceDataPtr; /* Pointer to the device data structure. */
 136:../Generated_Code/I2C2.c **** 
 137:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 138:../Generated_Code/I2C2.c **** static I2C2_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 139:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 140:../Generated_Code/I2C2.c **** static I2C2_TDeviceDataPtr INT_I2C0__DEFAULT_RTOS_ISRPARAM;
 141:../Generated_Code/I2C2.c **** 
 142:../Generated_Code/I2C2.c **** #define AVAILABLE_EVENTS_MASK (LDD_I2C_ON_MASTER_BLOCK_SENT | LDD_I2C_ON_MASTER_BLOCK_RECEIVED | LD
 143:../Generated_Code/I2C2.c **** 
 144:../Generated_Code/I2C2.c **** /*
 145:../Generated_Code/I2C2.c **** ** ===================================================================
 146:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Interrupt (component I2C_LDD)
 147:../Generated_Code/I2C2.c **** **
 148:../Generated_Code/I2C2.c **** **     Description :
 149:../Generated_Code/I2C2.c **** **         The method services the interrupt of the selected peripheral(s)
 150:../Generated_Code/I2C2.c **** **         and eventually invokes event(s) of the component.
 151:../Generated_Code/I2C2.c **** **         This method is internal. It is used by Processor Expert only.
 152:../Generated_Code/I2C2.c **** ** ===================================================================
 153:../Generated_Code/I2C2.c **** */
 154:../Generated_Code/I2C2.c **** 
 155:../Generated_Code/I2C2.c **** PE_ISR(I2C2_Interrupt)
 156:../Generated_Code/I2C2.c **** {
  38              		.loc 1 156 0
  39              		.cfi_startproc
  40 0000 90B5     		push	{r4, r7, lr}
  41              	.LCFI0:
  42              		.cfi_def_cfa_offset 12
  43              		.cfi_offset 4, -12
  44              		.cfi_offset 7, -8
  45              		.cfi_offset 14, -4
  46 0002 83B0     		sub	sp, sp, #12
  47              	.LCFI1:
  48              		.cfi_def_cfa_offset 24
  49 0004 00AF     		add	r7, sp, #0
  50              	.LCFI2:
  51              		.cfi_def_cfa_register 7
 157:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 158:../Generated_Code/I2C2.c ****   I2C2_TDeviceDataPtr DeviceDataPrv = INT_I2C0__DEFAULT_RTOS_ISRPARAM;
  52              		.loc 1 158 0
  53 0006 AA4B     		ldr	r3, .L16
  54 0008 1B68     		ldr	r3, [r3]
  55 000a 3B60     		str	r3, [r7]
 159:../Generated_Code/I2C2.c ****   LDD_I2C_TErrorMask ErrorMask = 0x00U; /* Temporary variable for error mask */
  56              		.loc 1 159 0
  57 000c BB1D     		add	r3, r7, #6
  58 000e 0022     		mov	r2, #0
  59 0010 1A80     		strh	r2, [r3]
 160:../Generated_Code/I2C2.c ****   register uint8_t Status;             /* Temporary variable for status register */
 161:../Generated_Code/I2C2.c **** 
 162:../Generated_Code/I2C2.c ****   Status = I2C_PDD_ReadStatusReg(I2C0_BASE_PTR); /* Safe status register */
  60              		.loc 1 162 0
  61 0012 A84B     		ldr	r3, .L16+4
  62 0014 DB78     		ldrb	r3, [r3, #3]
  63 0016 DCB2     		uxtb	r4, r3
 163:../Generated_Code/I2C2.c ****   I2C_PDD_ClearInterruptFlags(I2C0_BASE_PTR, (Status)); /* Clear interrupt flag */
  64              		.loc 1 163 0
  65 0018 A64B     		ldr	r3, .L16+4
  66 001a A64A     		ldr	r2, .L16+4
  67 001c D278     		ldrb	r2, [r2, #3]
  68 001e D2B2     		uxtb	r2, r2
  69 0020 D2B2     		uxtb	r2, r2
  70 0022 1221     		mov	r1, #18
  71 0024 8A43     		bic	r2, r1
  72 0026 D1B2     		uxtb	r1, r2
  73 0028 E2B2     		uxtb	r2, r4
  74 002a 0A43     		orr	r2, r1
  75 002c D2B2     		uxtb	r2, r2
  76 002e D2B2     		uxtb	r2, r2
  77 0030 DA70     		strb	r2, [r3, #3]
 164:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
  78              		.loc 1 164 0
  79 0032 A04B     		ldr	r3, .L16+4
  80 0034 9B78     		ldrb	r3, [r3, #2]
  81 0036 DBB2     		uxtb	r3, r3
  82 0038 1A1C     		mov	r2, r3
  83 003a 2023     		mov	r3, #32
  84 003c 1340     		and	r3, r2
  85 003e 00D1     		bne	.LCB45
  86 0040 FFE0     		b	.L2	@long jump
  87              	.LCB45:
 165:../Generated_Code/I2C2.c ****     if (I2C_PDD_GetTransmitMode(I2C0_BASE_PTR) == I2C_PDD_TX_DIRECTION) { /* Is device in Tx mode? 
  88              		.loc 1 165 0
  89 0042 9C4B     		ldr	r3, .L16+4
  90 0044 9B78     		ldrb	r3, [r3, #2]
  91 0046 DBB2     		uxtb	r3, r3
  92 0048 1A1C     		mov	r2, r3
  93 004a 1023     		mov	r3, #16
  94 004c 1340     		and	r3, r2
  95 004e 00D1     		bne	.LCB53
  96 0050 B6E0     		b	.L3	@long jump
  97              	.LCB53:
 166:../Generated_Code/I2C2.c ****       if ((Status & I2C_PDD_RX_ACKNOWLEDGE) != 0x00U){ /* NACK received? */
  98              		.loc 1 166 0
  99 0052 221C     		mov	r2, r4
 100 0054 0123     		mov	r3, #1
 101 0056 1340     		and	r3, r2
 102 0058 2AD0     		beq	.L4
 167:../Generated_Code/I2C2.c ****         I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave mode (s
 103              		.loc 1 167 0
 104 005a 964B     		ldr	r3, .L16+4
 105 005c 954A     		ldr	r2, .L16+4
 106 005e 9278     		ldrb	r2, [r2, #2]
 107 0060 D2B2     		uxtb	r2, r2
 108 0062 2021     		mov	r1, #32
 109 0064 8A43     		bic	r2, r1
 110 0066 D2B2     		uxtb	r2, r2
 111 0068 9A70     		strb	r2, [r3, #2]
 168:../Generated_Code/I2C2.c ****         I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 112              		.loc 1 168 0
 113 006a 924B     		ldr	r3, .L16+4
 114 006c 914A     		ldr	r2, .L16+4
 115 006e 9278     		ldrb	r2, [r2, #2]
 116 0070 D2B2     		uxtb	r2, r2
 117 0072 1021     		mov	r1, #16
 118 0074 8A43     		bic	r2, r1
 119 0076 D2B2     		uxtb	r2, r2
 120 0078 9A70     		strb	r2, [r3, #2]
 169:../Generated_Code/I2C2.c ****         DeviceDataPrv->OutLenM = 0x00U; /* No character for sending */
 121              		.loc 1 169 0
 122 007a 3B68     		ldr	r3, [r7]
 123 007c 0022     		mov	r2, #0
 124 007e 9A81     		strh	r2, [r3, #12]
 170:../Generated_Code/I2C2.c ****         DeviceDataPrv->InpLenM = 0x00U; /* No character for reception */
 125              		.loc 1 170 0
 126 0080 3B68     		ldr	r3, [r7]
 127 0082 0022     		mov	r2, #0
 128 0084 DA80     		strh	r2, [r3, #6]
 171:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* No character for sending or rec
 129              		.loc 1 171 0
 130 0086 3B68     		ldr	r3, [r7]
 131 0088 1B78     		ldrb	r3, [r3]
 132 008a 0122     		mov	r2, #1
 133 008c 9343     		bic	r3, r2
 134 008e DAB2     		uxtb	r2, r3
 135 0090 3B68     		ldr	r3, [r7]
 136 0092 1A70     		strb	r2, [r3]
 172:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Set the flag */
 137              		.loc 1 172 0
 138 0094 3B68     		ldr	r3, [r7]
 139 0096 1B78     		ldrb	r3, [r3]
 140 0098 0622     		mov	r2, #6
 141 009a 1343     		orr	r3, r2
 142 009c DAB2     		uxtb	r2, r3
 143 009e 3B68     		ldr	r3, [r7]
 144 00a0 1A70     		strb	r2, [r3]
 173:../Generated_Code/I2C2.c ****         ErrorMask |= LDD_I2C_MASTER_NACK; /* Set the Master Nack error mask */
 145              		.loc 1 173 0
 146 00a2 BB1D     		add	r3, r7, #6
 147 00a4 BA1D     		add	r2, r7, #6
 148 00a6 1288     		ldrh	r2, [r2]
 149 00a8 0821     		mov	r1, #8
 150 00aa 0A43     		orr	r2, r1
 151 00ac 1A80     		strh	r2, [r3]
 152 00ae EAE0     		b	.L5
 153              	.L4:
 174:../Generated_Code/I2C2.c ****       } else {
 175:../Generated_Code/I2C2.c ****         if ((DeviceDataPrv->SerFlag & ADDR_COMPLETE) != 0x00U) { /* If 10-bit addr has been complet
 154              		.loc 1 175 0
 155 00b0 3B68     		ldr	r3, [r7]
 156 00b2 1B78     		ldrb	r3, [r3]
 157 00b4 1A1C     		mov	r2, r3
 158 00b6 0223     		mov	r3, #2
 159 00b8 1340     		and	r3, r2
 160 00ba 00D1     		bne	.LCB111
 161 00bc 74E0     		b	.L6	@long jump
 162              	.LCB111:
 176:../Generated_Code/I2C2.c ****           if (DeviceDataPrv->OutLenM != 0x00U) { /* Is any char. for transmitting? */
 163              		.loc 1 176 0
 164 00be 3B68     		ldr	r3, [r7]
 165 00c0 9B89     		ldrh	r3, [r3, #12]
 166 00c2 002B     		cmp	r3, #0
 167 00c4 0ED0     		beq	.L7
 177:../Generated_Code/I2C2.c ****             DeviceDataPrv->OutLenM--;  /* Decrease number of chars for the transmit */
 168              		.loc 1 177 0
 169 00c6 3B68     		ldr	r3, [r7]
 170 00c8 9B89     		ldrh	r3, [r3, #12]
 171 00ca 013B     		sub	r3, r3, #1
 172 00cc 9AB2     		uxth	r2, r3
 173 00ce 3B68     		ldr	r3, [r7]
 174 00d0 9A81     		strh	r2, [r3, #12]
 178:../Generated_Code/I2C2.c ****             I2C_PDD_WriteDataReg(I2C0_BASE_PTR, *(DeviceDataPrv->OutPtrM)++); /* Send character */
 175              		.loc 1 178 0
 176 00d2 784A     		ldr	r2, .L16+4
 177 00d4 3B68     		ldr	r3, [r7]
 178 00d6 1B69     		ldr	r3, [r3, #16]
 179 00d8 1978     		ldrb	r1, [r3]
 180 00da 1171     		strb	r1, [r2, #4]
 181 00dc 5A1C     		add	r2, r3, #1
 182 00de 3B68     		ldr	r3, [r7]
 183 00e0 1A61     		str	r2, [r3, #16]
 184 00e2 D0E0     		b	.L5
 185              	.L7:
 179:../Generated_Code/I2C2.c ****           }
 180:../Generated_Code/I2C2.c ****           else {
 181:../Generated_Code/I2C2.c ****             if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 186              		.loc 1 181 0
 187 00e4 3B68     		ldr	r3, [r7]
 188 00e6 DB88     		ldrh	r3, [r3, #6]
 189 00e8 002B     		cmp	r3, #0
 190 00ea 3CD0     		beq	.L8
 182:../Generated_Code/I2C2.c ****               if ((DeviceDataPrv->SerFlag & REP_ADDR_COMPLETE) != 0x00U) { /* If repeated start and
 191              		.loc 1 182 0
 192 00ec 3B68     		ldr	r3, [r7]
 193 00ee 1B78     		ldrb	r3, [r3]
 194 00f0 1A1C     		mov	r2, r3
 195 00f2 0423     		mov	r3, #4
 196 00f4 1340     		and	r3, r2
 197 00f6 1FD0     		beq	.L9
 183:../Generated_Code/I2C2.c ****                 if (DeviceDataPrv->InpLenM == 0x01U) { /* If only one char to receive */
 198              		.loc 1 183 0
 199 00f8 3B68     		ldr	r3, [r7]
 200 00fa DB88     		ldrh	r3, [r3, #6]
 201 00fc 012B     		cmp	r3, #1
 202 00fe 08D1     		bne	.L10
 184:../Generated_Code/I2C2.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_DISABLE); /* then transmit A
 203              		.loc 1 184 0
 204 0100 6C4B     		ldr	r3, .L16+4
 205 0102 6C4A     		ldr	r2, .L16+4
 206 0104 9278     		ldrb	r2, [r2, #2]
 207 0106 D2B2     		uxtb	r2, r2
 208 0108 0821     		mov	r1, #8
 209 010a 0A43     		orr	r2, r1
 210 010c D2B2     		uxtb	r2, r2
 211 010e 9A70     		strb	r2, [r3, #2]
 212 0110 07E0     		b	.L11
 213              	.L10:
 185:../Generated_Code/I2C2.c ****                 } else {
 186:../Generated_Code/I2C2.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_ENABLE); /* else transmit AC
 214              		.loc 1 186 0
 215 0112 684B     		ldr	r3, .L16+4
 216 0114 674A     		ldr	r2, .L16+4
 217 0116 9278     		ldrb	r2, [r2, #2]
 218 0118 D2B2     		uxtb	r2, r2
 219 011a 0821     		mov	r1, #8
 220 011c 8A43     		bic	r2, r1
 221 011e D2B2     		uxtb	r2, r2
 222 0120 9A70     		strb	r2, [r3, #2]
 223              	.L11:
 187:../Generated_Code/I2C2.c ****                 }
 188:../Generated_Code/I2C2.c ****                 I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 224              		.loc 1 188 0
 225 0122 644B     		ldr	r3, .L16+4
 226 0124 634A     		ldr	r2, .L16+4
 227 0126 9278     		ldrb	r2, [r2, #2]
 228 0128 D2B2     		uxtb	r2, r2
 229 012a 1021     		mov	r1, #16
 230 012c 8A43     		bic	r2, r1
 231 012e D2B2     		uxtb	r2, r2
 232 0130 9A70     		strb	r2, [r3, #2]
 189:../Generated_Code/I2C2.c ****                 (void)I2C_PDD_ReadDataReg(I2C0_BASE_PTR); /* Dummy read character */
 233              		.loc 1 189 0
 234 0132 604B     		ldr	r3, .L16+4
 235 0134 1B79     		ldrb	r3, [r3, #4]
 236 0136 A6E0     		b	.L5
 237              	.L9:
 190:../Generated_Code/I2C2.c ****               } else {                 /* Repeated address has not been completed for 10-bit addres
 191:../Generated_Code/I2C2.c ****                 I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* Repeat start cycle generated */
 238              		.loc 1 191 0
 239 0138 5E4B     		ldr	r3, .L16+4
 240 013a 5E4A     		ldr	r2, .L16+4
 241 013c 9278     		ldrb	r2, [r2, #2]
 242 013e D2B2     		uxtb	r2, r2
 243 0140 0421     		mov	r1, #4
 244 0142 0A43     		orr	r2, r1
 245 0144 D2B2     		uxtb	r2, r2
 246 0146 9A70     		strb	r2, [r3, #2]
 192:../Generated_Code/I2C2.c ****                 I2C_PDD_WriteDataReg(I2C0_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddrHigh | 0x01U)
 247              		.loc 1 192 0
 248 0148 5A4B     		ldr	r3, .L16+4
 249 014a 3A68     		ldr	r2, [r7]
 250 014c 5279     		ldrb	r2, [r2, #5]
 251 014e 0121     		mov	r1, #1
 252 0150 0A43     		orr	r2, r1
 253 0152 D2B2     		uxtb	r2, r2
 254 0154 1A71     		strb	r2, [r3, #4]
 193:../Generated_Code/I2C2.c ****                 DeviceDataPrv->SerFlag |= REP_ADDR_COMPLETE;
 255              		.loc 1 193 0
 256 0156 3B68     		ldr	r3, [r7]
 257 0158 1B78     		ldrb	r3, [r3]
 258 015a 0422     		mov	r2, #4
 259 015c 1343     		orr	r3, r2
 260 015e DAB2     		uxtb	r2, r3
 261 0160 3B68     		ldr	r3, [r7]
 262 0162 1A70     		strb	r2, [r3]
 263 0164 8FE0     		b	.L5
 264              	.L8:
 194:../Generated_Code/I2C2.c ****               }
 195:../Generated_Code/I2C2.c ****             }
 196:../Generated_Code/I2C2.c ****             else {
 197:../Generated_Code/I2C2.c ****               DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 265              		.loc 1 197 0
 266 0166 3B68     		ldr	r3, [r7]
 267 0168 1B78     		ldrb	r3, [r3]
 268 016a 0122     		mov	r2, #1
 269 016c 9343     		bic	r3, r2
 270 016e DAB2     		uxtb	r2, r3
 271 0170 3B68     		ldr	r3, [r7]
 272 0172 1A70     		strb	r2, [r3]
 198:../Generated_Code/I2C2.c ****               if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 273              		.loc 1 198 0
 274 0174 3B68     		ldr	r3, [r7]
 275 0176 5B78     		ldrb	r3, [r3, #1]
 276 0178 012B     		cmp	r3, #1
 277 017a 0FD1     		bne	.L12
 199:../Generated_Code/I2C2.c ****                 I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave
 278              		.loc 1 199 0
 279 017c 4D4B     		ldr	r3, .L16+4
 280 017e 4D4A     		ldr	r2, .L16+4
 281 0180 9278     		ldrb	r2, [r2, #2]
 282 0182 D2B2     		uxtb	r2, r2
 283 0184 2021     		mov	r1, #32
 284 0186 8A43     		bic	r2, r1
 285 0188 D2B2     		uxtb	r2, r2
 286 018a 9A70     		strb	r2, [r3, #2]
 200:../Generated_Code/I2C2.c ****                 I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 287              		.loc 1 200 0
 288 018c 494B     		ldr	r3, .L16+4
 289 018e 494A     		ldr	r2, .L16+4
 290 0190 9278     		ldrb	r2, [r2, #2]
 291 0192 D2B2     		uxtb	r2, r2
 292 0194 1021     		mov	r1, #16
 293 0196 8A43     		bic	r2, r1
 294 0198 D2B2     		uxtb	r2, r2
 295 019a 9A70     		strb	r2, [r3, #2]
 296              	.L12:
 201:../Generated_Code/I2C2.c ****               }
 202:../Generated_Code/I2C2.c ****               I2C2_OnMasterBlockSent(DeviceDataPrv->UserData); /* Invoke OnMasterBlockSent event */
 297              		.loc 1 202 0
 298 019c 3B68     		ldr	r3, [r7]
 299 019e 5B69     		ldr	r3, [r3, #20]
 300 01a0 181C     		mov	r0, r3
 301 01a2 FFF7FEFF 		bl	I2C2_OnMasterBlockSent
 302 01a6 6EE0     		b	.L5
 303              	.L6:
 203:../Generated_Code/I2C2.c ****             }
 204:../Generated_Code/I2C2.c ****           }
 205:../Generated_Code/I2C2.c ****         } else {
 206:../Generated_Code/I2C2.c ****           I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send second part of the
 304              		.loc 1 206 0
 305 01a8 424B     		ldr	r3, .L16+4
 306 01aa 3A68     		ldr	r2, [r7]
 307 01ac 1279     		ldrb	r2, [r2, #4]
 308 01ae 1A71     		strb	r2, [r3, #4]
 207:../Generated_Code/I2C2.c ****           DeviceDataPrv->SerFlag |= (ADDR_COMPLETE); /* Address complete */
 309              		.loc 1 207 0
 310 01b0 3B68     		ldr	r3, [r7]
 311 01b2 1B78     		ldrb	r3, [r3]
 312 01b4 0222     		mov	r2, #2
 313 01b6 1343     		orr	r3, r2
 314 01b8 DAB2     		uxtb	r2, r3
 315 01ba 3B68     		ldr	r3, [r7]
 316 01bc 1A70     		strb	r2, [r3]
 317 01be 62E0     		b	.L5
 318              	.L3:
 208:../Generated_Code/I2C2.c ****         }
 209:../Generated_Code/I2C2.c ****       }
 210:../Generated_Code/I2C2.c ****     }
 211:../Generated_Code/I2C2.c ****     else {
 212:../Generated_Code/I2C2.c ****       DeviceDataPrv->InpLenM--;        /* Decrease number of chars for the receive */
 319              		.loc 1 212 0
 320 01c0 3B68     		ldr	r3, [r7]
 321 01c2 DB88     		ldrh	r3, [r3, #6]
 322 01c4 013B     		sub	r3, r3, #1
 323 01c6 9AB2     		uxth	r2, r3
 324 01c8 3B68     		ldr	r3, [r7]
 325 01ca DA80     		strh	r2, [r3, #6]
 213:../Generated_Code/I2C2.c ****       if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 326              		.loc 1 213 0
 327 01cc 3B68     		ldr	r3, [r7]
 328 01ce DB88     		ldrh	r3, [r3, #6]
 329 01d0 002B     		cmp	r3, #0
 330 01d2 0CD0     		beq	.L13
 214:../Generated_Code/I2C2.c ****         if (DeviceDataPrv->InpLenM == 0x01U) {
 331              		.loc 1 214 0
 332 01d4 3B68     		ldr	r3, [r7]
 333 01d6 DB88     		ldrh	r3, [r3, #6]
 334 01d8 012B     		cmp	r3, #1
 335 01da 1FD1     		bne	.L14
 215:../Generated_Code/I2C2.c ****           I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_DISABLE); /* Transmit NACK */
 336              		.loc 1 215 0
 337 01dc 354B     		ldr	r3, .L16+4
 338 01de 354A     		ldr	r2, .L16+4
 339 01e0 9278     		ldrb	r2, [r2, #2]
 340 01e2 D2B2     		uxtb	r2, r2
 341 01e4 0821     		mov	r1, #8
 342 01e6 0A43     		orr	r2, r1
 343 01e8 D2B2     		uxtb	r2, r2
 344 01ea 9A70     		strb	r2, [r3, #2]
 345 01ec 16E0     		b	.L14
 346              	.L13:
 216:../Generated_Code/I2C2.c ****         }
 217:../Generated_Code/I2C2.c ****       } else {
 218:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 347              		.loc 1 218 0
 348 01ee 3B68     		ldr	r3, [r7]
 349 01f0 1B78     		ldrb	r3, [r3]
 350 01f2 0122     		mov	r2, #1
 351 01f4 9343     		bic	r3, r2
 352 01f6 DAB2     		uxtb	r2, r3
 353 01f8 3B68     		ldr	r3, [r7]
 354 01fa 1A70     		strb	r2, [r3]
 219:../Generated_Code/I2C2.c ****         I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* If no, switch device to slave 
 355              		.loc 1 219 0
 356 01fc 2D4B     		ldr	r3, .L16+4
 357 01fe 2D4A     		ldr	r2, .L16+4
 358 0200 9278     		ldrb	r2, [r2, #2]
 359 0202 D2B2     		uxtb	r2, r2
 360 0204 2021     		mov	r1, #32
 361 0206 8A43     		bic	r2, r1
 362 0208 D2B2     		uxtb	r2, r2
 363 020a 9A70     		strb	r2, [r3, #2]
 220:../Generated_Code/I2C2.c ****         I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_ENABLE); /* Transmit ACK */
 364              		.loc 1 220 0
 365 020c 294B     		ldr	r3, .L16+4
 366 020e 294A     		ldr	r2, .L16+4
 367 0210 9278     		ldrb	r2, [r2, #2]
 368 0212 D2B2     		uxtb	r2, r2
 369 0214 0821     		mov	r1, #8
 370 0216 8A43     		bic	r2, r1
 371 0218 D2B2     		uxtb	r2, r2
 372 021a 9A70     		strb	r2, [r3, #2]
 373              	.L14:
 221:../Generated_Code/I2C2.c ****       }
 222:../Generated_Code/I2C2.c ****       *(DeviceDataPrv->InpPtrM)++ = I2C_PDD_ReadDataReg(I2C0_BASE_PTR); /* Receive character */
 374              		.loc 1 222 0
 375 021c 3B68     		ldr	r3, [r7]
 376 021e 9B68     		ldr	r3, [r3, #8]
 377 0220 244A     		ldr	r2, .L16+4
 378 0222 1279     		ldrb	r2, [r2, #4]
 379 0224 D2B2     		uxtb	r2, r2
 380 0226 1A70     		strb	r2, [r3]
 381 0228 5A1C     		add	r2, r3, #1
 382 022a 3B68     		ldr	r3, [r7]
 383 022c 9A60     		str	r2, [r3, #8]
 223:../Generated_Code/I2C2.c ****       if (DeviceDataPrv->InpLenM == 0x00U) { /* Is any char. for reception? */
 384              		.loc 1 223 0
 385 022e 3B68     		ldr	r3, [r7]
 386 0230 DB88     		ldrh	r3, [r3, #6]
 387 0232 002B     		cmp	r3, #0
 388 0234 27D1     		bne	.L5
 224:../Generated_Code/I2C2.c ****         I2C2_OnMasterBlockReceived(DeviceDataPrv->UserData); /* Invoke OnMasterBlockReceived event 
 389              		.loc 1 224 0
 390 0236 3B68     		ldr	r3, [r7]
 391 0238 5B69     		ldr	r3, [r3, #20]
 392 023a 181C     		mov	r0, r3
 393 023c FFF7FEFF 		bl	I2C2_OnMasterBlockReceived
 394 0240 21E0     		b	.L5
 395              	.L2:
 225:../Generated_Code/I2C2.c ****       }
 226:../Generated_Code/I2C2.c ****     }
 227:../Generated_Code/I2C2.c ****   } else {
 228:../Generated_Code/I2C2.c ****     if ((Status & I2C_PDD_ARBIT_LOST) != 0x00U) { /* Arbitration lost? */
 396              		.loc 1 228 0
 397 0242 221C     		mov	r2, r4
 398 0244 1023     		mov	r3, #16
 399 0246 1340     		and	r3, r2
 400 0248 1DD0     		beq	.L5
 229:../Generated_Code/I2C2.c ****       DeviceDataPrv->OutLenM = 0x00U;  /* Any character is not for sent */
 401              		.loc 1 229 0
 402 024a 3B68     		ldr	r3, [r7]
 403 024c 0022     		mov	r2, #0
 404 024e 9A81     		strh	r2, [r3, #12]
 230:../Generated_Code/I2C2.c ****       DeviceDataPrv->InpLenM = 0x00U;  /* Any character is not for reception */
 405              		.loc 1 230 0
 406 0250 3B68     		ldr	r3, [r7]
 407 0252 0022     		mov	r2, #0
 408 0254 DA80     		strh	r2, [r3, #6]
 231:../Generated_Code/I2C2.c ****       DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for 
 409              		.loc 1 231 0
 410 0256 3B68     		ldr	r3, [r7]
 411 0258 0122     		mov	r2, #1
 412 025a 5A70     		strb	r2, [r3, #1]
 232:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Any character is not for sent or 
 413              		.loc 1 232 0
 414 025c 3B68     		ldr	r3, [r7]
 415 025e 1B78     		ldrb	r3, [r3]
 416 0260 0122     		mov	r2, #1
 417 0262 9343     		bic	r3, r2
 418 0264 DAB2     		uxtb	r2, r3
 419 0266 3B68     		ldr	r3, [r7]
 420 0268 1A70     		strb	r2, [r3]
 233:../Generated_Code/I2C2.c ****       I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 421              		.loc 1 233 0
 422 026a 124B     		ldr	r3, .L16+4
 423 026c 114A     		ldr	r2, .L16+4
 424 026e 9278     		ldrb	r2, [r2, #2]
 425 0270 D2B2     		uxtb	r2, r2
 426 0272 1021     		mov	r1, #16
 427 0274 8A43     		bic	r2, r1
 428 0276 D2B2     		uxtb	r2, r2
 429 0278 9A70     		strb	r2, [r3, #2]
 234:../Generated_Code/I2C2.c ****       ErrorMask |= LDD_I2C_ARBIT_LOST; /* Set the ArbitLost error mask */
 430              		.loc 1 234 0
 431 027a BB1D     		add	r3, r7, #6
 432 027c BA1D     		add	r2, r7, #6
 433 027e 1288     		ldrh	r2, [r2]
 434 0280 0421     		mov	r1, #4
 435 0282 0A43     		orr	r2, r1
 436 0284 1A80     		strh	r2, [r3]
 437              	.L5:
 235:../Generated_Code/I2C2.c ****     }
 236:../Generated_Code/I2C2.c ****   }
 237:../Generated_Code/I2C2.c ****   if (ErrorMask != 0x00U) {            /* Is any error mask set? */
 438              		.loc 1 237 0
 439 0286 BB1D     		add	r3, r7, #6
 440 0288 1B88     		ldrh	r3, [r3]
 441 028a 002B     		cmp	r3, #0
 442 028c 0CD0     		beq	.L1
 238:../Generated_Code/I2C2.c ****     DeviceDataPrv->ErrorMask |= ErrorMask; /* Update list of error mask value */
 443              		.loc 1 238 0
 444 028e 3B68     		ldr	r3, [r7]
 445 0290 5A88     		ldrh	r2, [r3, #2]
 446 0292 BB1D     		add	r3, r7, #6
 447 0294 1B88     		ldrh	r3, [r3]
 448 0296 1343     		orr	r3, r2
 449 0298 9AB2     		uxth	r2, r3
 450 029a 3B68     		ldr	r3, [r7]
 451 029c 5A80     		strh	r2, [r3, #2]
 239:../Generated_Code/I2C2.c ****     I2C2_OnError(DeviceDataPrv->UserData); /* If yes then invoke user event */
 452              		.loc 1 239 0
 453 029e 3B68     		ldr	r3, [r7]
 454 02a0 5B69     		ldr	r3, [r3, #20]
 455 02a2 181C     		mov	r0, r3
 456 02a4 FFF7FEFF 		bl	I2C2_OnError
 457              	.L1:
 240:../Generated_Code/I2C2.c ****   }
 241:../Generated_Code/I2C2.c **** }
 458              		.loc 1 241 0
 459 02a8 BD46     		mov	sp, r7
 460 02aa 03B0     		add	sp, sp, #12
 461              		@ sp needed for prologue
 462 02ac 90BD     		pop	{r4, r7, pc}
 463              	.L17:
 464 02ae C046     		.align	2
 465              	.L16:
 466 02b0 00000000 		.word	INT_I2C0__DEFAULT_RTOS_ISRPARAM
 467 02b4 00600640 		.word	1074159616
 468              		.cfi_endproc
 469              	.LFE0:
 471              		.section	.text.I2C2_Init,"ax",%progbits
 472              		.align	2
 473              		.global	I2C2_Init
 474              		.code	16
 475              		.thumb_func
 477              	I2C2_Init:
 478              	.LFB1:
 242:../Generated_Code/I2C2.c **** 
 243:../Generated_Code/I2C2.c **** /*
 244:../Generated_Code/I2C2.c **** ** ===================================================================
 245:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Init (component I2C_LDD)
 246:../Generated_Code/I2C2.c **** **
 247:../Generated_Code/I2C2.c **** **     Description :
 248:../Generated_Code/I2C2.c **** **         Initializes the device. Allocates memory for the device data
 249:../Generated_Code/I2C2.c **** **         structure, allocates interrupt vectors and sets interrupt
 250:../Generated_Code/I2C2.c **** **         priority, sets pin routing, sets timing, etc.
 251:../Generated_Code/I2C2.c **** **         If the "Enable in init. code" is set to "yes" value then the
 252:../Generated_Code/I2C2.c **** **         device is also enabled(see the description of the Enable()
 253:../Generated_Code/I2C2.c **** **         method). In this case the Enable() method is not necessary
 254:../Generated_Code/I2C2.c **** **         and needn't to be generated. 
 255:../Generated_Code/I2C2.c **** **         This method can be called only once. Before the second call
 256:../Generated_Code/I2C2.c **** **         of Init() the Deinit() must be called first.
 257:../Generated_Code/I2C2.c **** **     Parameters  :
 258:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 259:../Generated_Code/I2C2.c **** **       * UserDataPtr     - Pointer to the user or
 260:../Generated_Code/I2C2.c **** **                           RTOS specific data. This pointer will be
 261:../Generated_Code/I2C2.c **** **                           passed as an event or callback parameter.
 262:../Generated_Code/I2C2.c **** **     Returns     :
 263:../Generated_Code/I2C2.c **** **         ---             - Pointer to the device data structure. 
 264:../Generated_Code/I2C2.c **** ** ===================================================================
 265:../Generated_Code/I2C2.c **** */
 266:../Generated_Code/I2C2.c **** LDD_TDeviceData* I2C2_Init(LDD_TUserData *UserDataPtr)
 267:../Generated_Code/I2C2.c **** {
 479              		.loc 1 267 0
 480              		.cfi_startproc
 481 0000 80B5     		push	{r7, lr}
 482              	.LCFI3:
 483              		.cfi_def_cfa_offset 8
 484              		.cfi_offset 7, -8
 485              		.cfi_offset 14, -4
 486 0002 84B0     		sub	sp, sp, #16
 487              	.LCFI4:
 488              		.cfi_def_cfa_offset 24
 489 0004 00AF     		add	r7, sp, #0
 490              	.LCFI5:
 491              		.cfi_def_cfa_register 7
 492 0006 7860     		str	r0, [r7, #4]
 268:../Generated_Code/I2C2.c ****   /* Allocate HAL device structure */
 269:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv;
 270:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 271:../Generated_Code/I2C2.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 493              		.loc 1 271 0
 494 0008 3B4B     		ldr	r3, .L20
 495 000a FB60     		str	r3, [r7, #12]
 272:../Generated_Code/I2C2.c **** 
 273:../Generated_Code/I2C2.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
 496              		.loc 1 273 0
 497 000c FB68     		ldr	r3, [r7, #12]
 498 000e 7A68     		ldr	r2, [r7, #4]
 499 0010 5A61     		str	r2, [r3, #20]
 274:../Generated_Code/I2C2.c **** 
 275:../Generated_Code/I2C2.c ****   /* Allocate interrupt vector */
 276:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 277:../Generated_Code/I2C2.c ****   INT_I2C0__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
 500              		.loc 1 277 0
 501 0012 3A4B     		ldr	r3, .L20+4
 502 0014 FA68     		ldr	r2, [r7, #12]
 503 0016 1A60     		str	r2, [r3]
 278:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag = ADDR_7;     /* Reset all flags start with 7-bit address mode */
 504              		.loc 1 278 0
 505 0018 FB68     		ldr	r3, [r7, #12]
 506 001a 2022     		mov	r2, #32
 507 001c 1A70     		strb	r2, [r3]
 279:../Generated_Code/I2C2.c ****   DeviceDataPrv->SlaveAddr = 0x3AU;    /* Set variable for slave address */
 508              		.loc 1 279 0
 509 001e FB68     		ldr	r3, [r7, #12]
 510 0020 3A22     		mov	r2, #58
 511 0022 1A71     		strb	r2, [r3, #4]
 280:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for mast
 512              		.loc 1 280 0
 513 0024 FB68     		ldr	r3, [r7, #12]
 514 0026 0122     		mov	r2, #1
 515 0028 5A70     		strb	r2, [r3, #1]
 281:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpLenM = 0x00U;      /* Set zero counter of data of reception */
 516              		.loc 1 281 0
 517 002a FB68     		ldr	r3, [r7, #12]
 518 002c 0022     		mov	r2, #0
 519 002e DA80     		strh	r2, [r3, #6]
 282:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutLenM = 0x00U;      /* Set zero counter of data of transmission */
 520              		.loc 1 282 0
 521 0030 FB68     		ldr	r3, [r7, #12]
 522 0032 0022     		mov	r2, #0
 523 0034 9A81     		strh	r2, [r3, #12]
 283:../Generated_Code/I2C2.c ****   DeviceDataPrv->ErrorMask = 0x00U;    /* Clear variable for errors mask value */
 524              		.loc 1 283 0
 525 0036 FB68     		ldr	r3, [r7, #12]
 526 0038 0022     		mov	r2, #0
 527 003a 5A80     		strh	r2, [r3, #2]
 284:../Generated_Code/I2C2.c ****   /* SIM_SCGC4: I2C0=1 */
 285:../Generated_Code/I2C2.c ****   SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK;                                                   
 528              		.loc 1 285 0
 529 003c 304A     		ldr	r2, .L20+8
 530 003e 3049     		ldr	r1, .L20+8
 531 0040 304B     		ldr	r3, .L20+12
 532 0042 CB58     		ldr	r3, [r1, r3]
 533 0044 4021     		mov	r1, #64
 534 0046 1943     		orr	r1, r3
 535 0048 2E4B     		ldr	r3, .L20+12
 536 004a D150     		str	r1, [r2, r3]
 286:../Generated_Code/I2C2.c ****   /* I2C0_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 287:../Generated_Code/I2C2.c ****   I2C0_C1 = 0x00U;                     /* Clear control register */
 537              		.loc 1 287 0
 538 004c 2E4B     		ldr	r3, .L20+16
 539 004e 0022     		mov	r2, #0
 540 0050 9A70     		strb	r2, [r3, #2]
 288:../Generated_Code/I2C2.c ****   /* I2C0_FLT: SHEN=0,STOPF=1,STOPIE=0,FLT=0 */
 289:../Generated_Code/I2C2.c ****   I2C0_FLT = I2C_FLT_STOPF_MASK;       /* Clear bus status interrupt flags */
 541              		.loc 1 289 0
 542 0052 2D4B     		ldr	r3, .L20+16
 543 0054 4022     		mov	r2, #64
 544 0056 9A71     		strb	r2, [r3, #6]
 290:../Generated_Code/I2C2.c ****   /* I2C0_S: TCF=0,IAAS=0,BUSY=0,ARBL=0,RAM=0,SRW=0,IICIF=1,RXAK=0 */
 291:../Generated_Code/I2C2.c ****   I2C0_S = I2C_S_IICIF_MASK;           /* Clear interrupt flag */
 545              		.loc 1 291 0
 546 0058 2B4B     		ldr	r3, .L20+16
 547 005a 0222     		mov	r2, #2
 548 005c DA70     		strb	r2, [r3, #3]
 292:../Generated_Code/I2C2.c ****   /* PORTE_PCR25: ISF=0,MUX=5 */
 293:../Generated_Code/I2C2.c ****   PORTE_PCR25 = (uint32_t)((PORTE_PCR25 & (uint32_t)~(uint32_t)(
 549              		.loc 1 293 0
 550 005e 2B4B     		ldr	r3, .L20+20
 551 0060 2A4A     		ldr	r2, .L20+20
 552 0062 516E     		ldr	r1, [r2, #100]
 553 0064 2A4A     		ldr	r2, .L20+24
 554 0066 0A40     		and	r2, r1
 555 0068 A021     		mov	r1, #160
 556 006a C900     		lsl	r1, r1, #3
 557 006c 0A43     		orr	r2, r1
 558 006e 5A66     		str	r2, [r3, #100]
 294:../Generated_Code/I2C2.c ****                  PORT_PCR_ISF_MASK |
 295:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x02)
 296:../Generated_Code/I2C2.c ****                 )) | (uint32_t)(
 297:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x05)
 298:../Generated_Code/I2C2.c ****                 ));                                                  
 299:../Generated_Code/I2C2.c ****   /* PORTE_PCR24: ISF=0,MUX=5 */
 300:../Generated_Code/I2C2.c ****   PORTE_PCR24 = (uint32_t)((PORTE_PCR24 & (uint32_t)~(uint32_t)(
 559              		.loc 1 300 0
 560 0070 264B     		ldr	r3, .L20+20
 561 0072 264A     		ldr	r2, .L20+20
 562 0074 116E     		ldr	r1, [r2, #96]
 563 0076 264A     		ldr	r2, .L20+24
 564 0078 0A40     		and	r2, r1
 565 007a A021     		mov	r1, #160
 566 007c C900     		lsl	r1, r1, #3
 567 007e 0A43     		orr	r2, r1
 568 0080 1A66     		str	r2, [r3, #96]
 301:../Generated_Code/I2C2.c ****                  PORT_PCR_ISF_MASK |
 302:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x02)
 303:../Generated_Code/I2C2.c ****                 )) | (uint32_t)(
 304:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x05)
 305:../Generated_Code/I2C2.c ****                 ));                                                  
 306:../Generated_Code/I2C2.c ****   /* NVIC_IPR2: PRI_8=0x80 */
 307:../Generated_Code/I2C2.c ****   NVIC_IPR2 = (uint32_t)((NVIC_IPR2 & (uint32_t)~(uint32_t)(
 569              		.loc 1 307 0
 570 0082 244A     		ldr	r2, .L20+28
 571 0084 2349     		ldr	r1, .L20+28
 572 0086 C223     		mov	r3, #194
 573 0088 9B00     		lsl	r3, r3, #2
 574 008a CB58     		ldr	r3, [r1, r3]
 575 008c FF21     		mov	r1, #255
 576 008e 8B43     		bic	r3, r1
 577 0090 8021     		mov	r1, #128
 578 0092 1943     		orr	r1, r3
 579 0094 C223     		mov	r3, #194
 580 0096 9B00     		lsl	r3, r3, #2
 581 0098 D150     		str	r1, [r2, r3]
 308:../Generated_Code/I2C2.c ****                NVIC_IP_PRI_8(0x7F)
 309:../Generated_Code/I2C2.c ****               )) | (uint32_t)(
 310:../Generated_Code/I2C2.c ****                NVIC_IP_PRI_8(0x80)
 311:../Generated_Code/I2C2.c ****               ));                                                  
 312:../Generated_Code/I2C2.c ****   /* NVIC_ISER: SETENA|=0x0100 */
 313:../Generated_Code/I2C2.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x0100);                                                   
 582              		.loc 1 313 0
 583 009a 1E4B     		ldr	r3, .L20+28
 584 009c 1D4A     		ldr	r2, .L20+28
 585 009e 1268     		ldr	r2, [r2]
 586 00a0 8021     		mov	r1, #128
 587 00a2 4900     		lsl	r1, r1, #1
 588 00a4 0A43     		orr	r2, r1
 589 00a6 1A60     		str	r2, [r3]
 314:../Generated_Code/I2C2.c ****   /* I2C0_C2: GCAEN=0,ADEXT=0,HDRS=0,SBRC=0,RMEN=0,AD=0 */
 315:../Generated_Code/I2C2.c ****   I2C0_C2 = 0x00U;                                                   
 590              		.loc 1 315 0
 591 00a8 174B     		ldr	r3, .L20+16
 592 00aa 0022     		mov	r2, #0
 593 00ac 5A71     		strb	r2, [r3, #5]
 316:../Generated_Code/I2C2.c ****   /* I2C0_FLT: SHEN=0,STOPF=0,STOPIE=0,FLT=0 */
 317:../Generated_Code/I2C2.c ****   I2C0_FLT = 0x00U;                    /* Set glitch filter register */
 594              		.loc 1 317 0
 595 00ae 164B     		ldr	r3, .L20+16
 596 00b0 0022     		mov	r2, #0
 597 00b2 9A71     		strb	r2, [r3, #6]
 318:../Generated_Code/I2C2.c ****   /* I2C0_SMB: FACK=0,ALERTEN=0,SIICAEN=0,TCKSEL=0,SLTF=1,SHTF1=0,SHTF2=0,SHTF2IE=0 */
 319:../Generated_Code/I2C2.c ****   I2C0_SMB = I2C_SMB_SLTF_MASK;                                                   
 598              		.loc 1 319 0
 599 00b4 144B     		ldr	r3, .L20+16
 600 00b6 0822     		mov	r2, #8
 601 00b8 1A72     		strb	r2, [r3, #8]
 320:../Generated_Code/I2C2.c ****   /* I2C0_F: MULT=0,ICR=0 */
 321:../Generated_Code/I2C2.c ****   I2C0_F = 0x00U;                      /* Set prescaler bits */
 602              		.loc 1 321 0
 603 00ba 134B     		ldr	r3, .L20+16
 604 00bc 0022     		mov	r2, #0
 605 00be 5A70     		strb	r2, [r3, #1]
 322:../Generated_Code/I2C2.c ****   I2C_PDD_EnableDevice(I2C0_BASE_PTR, PDD_ENABLE); /* Enable device */
 606              		.loc 1 322 0
 607 00c0 114B     		ldr	r3, .L20+16
 608 00c2 114A     		ldr	r2, .L20+16
 609 00c4 9278     		ldrb	r2, [r2, #2]
 610 00c6 D2B2     		uxtb	r2, r2
 611 00c8 D2B2     		uxtb	r2, r2
 612 00ca 8021     		mov	r1, #128
 613 00cc 4942     		neg	r1, r1
 614 00ce 0A43     		orr	r2, r1
 615 00d0 D2B2     		uxtb	r2, r2
 616 00d2 D2B2     		uxtb	r2, r2
 617 00d4 9A70     		strb	r2, [r3, #2]
 323:../Generated_Code/I2C2.c ****   I2C_PDD_EnableInterrupt(I2C0_BASE_PTR); /* Enable interrupt */
 618              		.loc 1 323 0
 619 00d6 0C4B     		ldr	r3, .L20+16
 620 00d8 0B4A     		ldr	r2, .L20+16
 621 00da 9278     		ldrb	r2, [r2, #2]
 622 00dc D2B2     		uxtb	r2, r2
 623 00de 4021     		mov	r1, #64
 624 00e0 0A43     		orr	r2, r1
 625 00e2 D2B2     		uxtb	r2, r2
 626 00e4 9A70     		strb	r2, [r3, #2]
 324:../Generated_Code/I2C2.c ****   /* Registration of the device structure */
 325:../Generated_Code/I2C2.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_I2C2_ID,DeviceDataPrv);
 627              		.loc 1 325 0
 628 00e6 0C4B     		ldr	r3, .L20+32
 629 00e8 FA68     		ldr	r2, [r7, #12]
 630 00ea DA60     		str	r2, [r3, #12]
 326:../Generated_Code/I2C2.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 631              		.loc 1 326 0
 632 00ec FB68     		ldr	r3, [r7, #12]
 327:../Generated_Code/I2C2.c **** }
 633              		.loc 1 327 0
 634 00ee 181C     		mov	r0, r3
 635 00f0 BD46     		mov	sp, r7
 636 00f2 04B0     		add	sp, sp, #16
 637              		@ sp needed for prologue
 638 00f4 80BD     		pop	{r7, pc}
 639              	.L21:
 640 00f6 C046     		.align	2
 641              	.L20:
 642 00f8 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 643 00fc 00000000 		.word	INT_I2C0__DEFAULT_RTOS_ISRPARAM
 644 0100 00700440 		.word	1074032640
 645 0104 34100000 		.word	4148
 646 0108 00600640 		.word	1074159616
 647 010c 00D00440 		.word	1074057216
 648 0110 FFF8FFFE 		.word	-16779009
 649 0114 00E100E0 		.word	-536813312
 650 0118 00000000 		.word	PE_LDD_DeviceDataList
 651              		.cfi_endproc
 652              	.LFE1:
 654              		.section	.text.I2C2_Deinit,"ax",%progbits
 655              		.align	2
 656              		.global	I2C2_Deinit
 657              		.code	16
 658              		.thumb_func
 660              	I2C2_Deinit:
 661              	.LFB2:
 328:../Generated_Code/I2C2.c **** 
 329:../Generated_Code/I2C2.c **** /*
 330:../Generated_Code/I2C2.c **** ** ===================================================================
 331:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Deinit (component I2C_LDD)
 332:../Generated_Code/I2C2.c **** **
 333:../Generated_Code/I2C2.c **** **     Description :
 334:../Generated_Code/I2C2.c **** **         Deinitializes the device. Switches off the device, frees the
 335:../Generated_Code/I2C2.c **** **         device data structure memory, interrupts vectors, etc.
 336:../Generated_Code/I2C2.c **** **     Parameters  :
 337:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 338:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 339:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 340:../Generated_Code/I2C2.c **** **     Returns     : Nothing
 341:../Generated_Code/I2C2.c **** ** ===================================================================
 342:../Generated_Code/I2C2.c **** */
 343:../Generated_Code/I2C2.c **** void I2C2_Deinit(LDD_TDeviceData *DeviceDataPtr)
 344:../Generated_Code/I2C2.c **** {
 662              		.loc 1 344 0
 663              		.cfi_startproc
 664 0000 80B5     		push	{r7, lr}
 665              	.LCFI6:
 666              		.cfi_def_cfa_offset 8
 667              		.cfi_offset 7, -8
 668              		.cfi_offset 14, -4
 669 0002 82B0     		sub	sp, sp, #8
 670              	.LCFI7:
 671              		.cfi_def_cfa_offset 16
 672 0004 00AF     		add	r7, sp, #0
 673              	.LCFI8:
 674              		.cfi_def_cfa_register 7
 675 0006 7860     		str	r0, [r7, #4]
 345:../Generated_Code/I2C2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 346:../Generated_Code/I2C2.c **** 
 347:../Generated_Code/I2C2.c ****   /* I2C0_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 348:../Generated_Code/I2C2.c ****   I2C0_C1 = 0x00U;                     /* Reset I2C Control register */
 676              		.loc 1 348 0
 677 0008 094B     		ldr	r3, .L23
 678 000a 0022     		mov	r2, #0
 679 000c 9A70     		strb	r2, [r3, #2]
 349:../Generated_Code/I2C2.c ****   /* Restoring the interrupt vector */
 350:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 351:../Generated_Code/I2C2.c ****   /* Unregistration of the device structure */
 352:../Generated_Code/I2C2.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_I2C2_ID);
 680              		.loc 1 352 0
 681 000e 094B     		ldr	r3, .L23+4
 682 0010 0022     		mov	r2, #0
 683 0012 DA60     		str	r2, [r3, #12]
 353:../Generated_Code/I2C2.c ****   /* Deallocation of the device structure */
 354:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 355:../Generated_Code/I2C2.c ****   /* SIM_SCGC4: I2C0=0 */
 356:../Generated_Code/I2C2.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_I2C0_MASK);                                         
 684              		.loc 1 356 0
 685 0014 084A     		ldr	r2, .L23+8
 686 0016 0849     		ldr	r1, .L23+8
 687 0018 084B     		ldr	r3, .L23+12
 688 001a CB58     		ldr	r3, [r1, r3]
 689 001c 4021     		mov	r1, #64
 690 001e 181C     		mov	r0, r3
 691 0020 8843     		bic	r0, r1
 692 0022 011C     		mov	r1, r0
 693 0024 054B     		ldr	r3, .L23+12
 694 0026 D150     		str	r1, [r2, r3]
 357:../Generated_Code/I2C2.c **** }
 695              		.loc 1 357 0
 696 0028 BD46     		mov	sp, r7
 697 002a 02B0     		add	sp, sp, #8
 698              		@ sp needed for prologue
 699 002c 80BD     		pop	{r7, pc}
 700              	.L24:
 701 002e C046     		.align	2
 702              	.L23:
 703 0030 00600640 		.word	1074159616
 704 0034 00000000 		.word	PE_LDD_DeviceDataList
 705 0038 00700440 		.word	1074032640
 706 003c 34100000 		.word	4148
 707              		.cfi_endproc
 708              	.LFE2:
 710              		.section	.text.I2C2_MasterSendBlock,"ax",%progbits
 711              		.align	2
 712              		.global	I2C2_MasterSendBlock
 713              		.code	16
 714              		.thumb_func
 716              	I2C2_MasterSendBlock:
 717              	.LFB3:
 358:../Generated_Code/I2C2.c **** 
 359:../Generated_Code/I2C2.c **** /*
 360:../Generated_Code/I2C2.c **** ** ===================================================================
 361:../Generated_Code/I2C2.c **** **     Method      :  I2C2_MasterSendBlock (component I2C_LDD)
 362:../Generated_Code/I2C2.c **** **
 363:../Generated_Code/I2C2.c **** **     Description :
 364:../Generated_Code/I2C2.c **** **         This method writes one (7-bit addressing) or two (10-bit
 365:../Generated_Code/I2C2.c **** **         addressing) slave address bytes inclusive of R/W bit = 0 to
 366:../Generated_Code/I2C2.c **** **         the I2C bus and then writes the block of characters to the
 367:../Generated_Code/I2C2.c **** **         bus. The slave address must be specified before, by the
 368:../Generated_Code/I2C2.c **** **         "SelectSlaveDevice" method or in component initialization
 369:../Generated_Code/I2C2.c **** **         section, "Target slave address init" property. If the method
 370:../Generated_Code/I2C2.c **** **         returns ERR_OK, it doesn't mean that transmission was
 371:../Generated_Code/I2C2.c **** **         successful. The state of transmission is detectable by means
 372:../Generated_Code/I2C2.c **** **         of events (OnMasterSendComplete or OnError). Data to be sent
 373:../Generated_Code/I2C2.c **** **         are not copied to an internal buffer and remains in the
 374:../Generated_Code/I2C2.c **** **         original location. Therefore the content of the buffer
 375:../Generated_Code/I2C2.c **** **         should not be changed until the transmission is complete.
 376:../Generated_Code/I2C2.c **** **         Event "OnMasterBlockSent"can be used to detect the end of
 377:../Generated_Code/I2C2.c **** **         the transmission. This method is available only for the
 378:../Generated_Code/I2C2.c **** **         MASTER or MASTER - SLAVE mode.
 379:../Generated_Code/I2C2.c **** **     Parameters  :
 380:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 381:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 382:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 383:../Generated_Code/I2C2.c **** **       * BufferPtr       - Pointer to the block of data
 384:../Generated_Code/I2C2.c **** **                           to send.
 385:../Generated_Code/I2C2.c **** **         Size            - Size of the data block.
 386:../Generated_Code/I2C2.c **** **         SendStop        - Parameter for generating I2C
 387:../Generated_Code/I2C2.c **** **                           Stop condition
 388:../Generated_Code/I2C2.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 389:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 390:../Generated_Code/I2C2.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 391:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 392:../Generated_Code/I2C2.c **** **     Returns     :
 393:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 394:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 395:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 396:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 397:../Generated_Code/I2C2.c **** **                           the active clock configuration
 398:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The I2C device is now running
 399:../Generated_Code/I2C2.c **** ** ===================================================================
 400:../Generated_Code/I2C2.c **** */
 401:../Generated_Code/I2C2.c **** LDD_TError I2C2_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TSize
 402:../Generated_Code/I2C2.c **** {
 718              		.loc 1 402 0
 719              		.cfi_startproc
 720 0000 80B5     		push	{r7, lr}
 721              	.LCFI9:
 722              		.cfi_def_cfa_offset 8
 723              		.cfi_offset 7, -8
 724              		.cfi_offset 14, -4
 725 0002 86B0     		sub	sp, sp, #24
 726              	.LCFI10:
 727              		.cfi_def_cfa_offset 32
 728 0004 00AF     		add	r7, sp, #0
 729              	.LCFI11:
 730              		.cfi_def_cfa_register 7
 731 0006 F860     		str	r0, [r7, #12]
 732 0008 B960     		str	r1, [r7, #8]
 733 000a 111C     		mov	r1, r2
 734 000c 1A1C     		mov	r2, r3
 735 000e BB1D     		add	r3, r7, #6
 736 0010 1980     		strh	r1, [r3]
 737 0012 7B1D     		add	r3, r7, #5
 738 0014 1A70     		strb	r2, [r3]
 403:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 739              		.loc 1 403 0
 740 0016 FB68     		ldr	r3, [r7, #12]
 741 0018 7B61     		str	r3, [r7, #20]
 404:../Generated_Code/I2C2.c **** 
 405:../Generated_Code/I2C2.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 742              		.loc 1 405 0
 743 001a BB1D     		add	r3, r7, #6
 744 001c 1B88     		ldrh	r3, [r3]
 745 001e 002B     		cmp	r3, #0
 746 0020 01D1     		bne	.L26
 406:../Generated_Code/I2C2.c ****     return ERR_OK;                     /* If zero then OK */
 747              		.loc 1 406 0
 748 0022 0023     		mov	r3, #0
 749 0024 AAE0     		b	.L27
 750              	.L26:
 407:../Generated_Code/I2C2.c ****   }
 408:../Generated_Code/I2C2.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 751              		.loc 1 408 0
 752 0026 7B69     		ldr	r3, [r7, #20]
 753 0028 5B78     		ldrb	r3, [r3, #1]
 754 002a 012B     		cmp	r3, #1
 755 002c 12D1     		bne	.L28
 409:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 756              		.loc 1 409 0
 757 002e 554B     		ldr	r3, .L39
 758 0030 DB78     		ldrb	r3, [r3, #3]
 759 0032 DBB2     		uxtb	r3, r3
 760 0034 1A1C     		mov	r2, r3
 761 0036 2023     		mov	r3, #32
 762 0038 1340     		and	r3, r2
 763 003a 09D1     		bne	.L29
 410:../Generated_Code/I2C2.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 764              		.loc 1 410 0
 765 003c 7B69     		ldr	r3, [r7, #20]
 766 003e 1B78     		ldrb	r3, [r3]
 767 0040 1A1C     		mov	r2, r3
 768 0042 0123     		mov	r3, #1
 769 0044 1340     		and	r3, r2
 409:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 770              		.loc 1 409 0
 771 0046 03D1     		bne	.L29
 411:../Generated_Code/I2C2.c ****        (DeviceDataPrv->OutLenM != 0x00U))  {
 772              		.loc 1 411 0
 773 0048 7B69     		ldr	r3, [r7, #20]
 774 004a 9B89     		ldrh	r3, [r3, #12]
 410:../Generated_Code/I2C2.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 775              		.loc 1 410 0
 776 004c 002B     		cmp	r3, #0
 777 004e 0DD0     		beq	.L30
 778              	.L29:
 412:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 779              		.loc 1 412 0
 780 0050 0823     		mov	r3, #8
 781 0052 93E0     		b	.L27
 782              	.L28:
 413:../Generated_Code/I2C2.c ****     }
 414:../Generated_Code/I2C2.c ****   } else {
 415:../Generated_Code/I2C2.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 783              		.loc 1 415 0
 784 0054 7B69     		ldr	r3, [r7, #20]
 785 0056 1B78     		ldrb	r3, [r3]
 786 0058 1A1C     		mov	r2, r3
 787 005a 0123     		mov	r3, #1
 788 005c 1340     		and	r3, r2
 789 005e 03D1     		bne	.L31
 416:../Generated_Code/I2C2.c ****       (DeviceDataPrv->OutLenM != 0x00U))  {
 790              		.loc 1 416 0
 791 0060 7B69     		ldr	r3, [r7, #20]
 792 0062 9B89     		ldrh	r3, [r3, #12]
 415:../Generated_Code/I2C2.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 793              		.loc 1 415 0
 794 0064 002B     		cmp	r3, #0
 795 0066 01D0     		beq	.L30
 796              	.L31:
 417:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 797              		.loc 1 417 0
 798 0068 0823     		mov	r3, #8
 799 006a 87E0     		b	.L27
 800              	.L30:
 418:../Generated_Code/I2C2.c ****     }
 419:../Generated_Code/I2C2.c ****   }
 420:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 421:../Generated_Code/I2C2.c ****   EnterCritical();
 801              		.loc 1 421 0
 802 006c 464B     		ldr	r3, .L39+4
 803 006e 1B78     		ldrb	r3, [r3]
 804 0070 DBB2     		uxtb	r3, r3
 805 0072 0133     		add	r3, r3, #1
 806 0074 DBB2     		uxtb	r3, r3
 807 0076 444A     		ldr	r2, .L39+4
 808 0078 191C     		add	r1, r3, #0
 809 007a 1170     		strb	r1, [r2]
 810 007c 012B     		cmp	r3, #1
 811 007e 04D1     		bne	.L32
 812              		.loc 1 421 0 is_stmt 0
 813 0080 424B     		ldr	r3, .L39+8
 814              	@ 421 "../Generated_Code/I2C2.c" 1
 815 0082 EFF31080 		MRS R0, PRIMASK
 816 0086 72B6     		CPSID i
 817 0088 1870     		STRB R0, [r3]
 818              	@ 0 "" 2
 819              		.code	16
 820              	.L32:
 422:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 821              		.loc 1 422 0 is_stmt 1
 822 008a 7B69     		ldr	r3, [r7, #20]
 823 008c 1B78     		ldrb	r3, [r3]
 824 008e 0122     		mov	r2, #1
 825 0090 1343     		orr	r3, r2
 826 0092 DAB2     		uxtb	r2, r3
 827 0094 7B69     		ldr	r3, [r7, #20]
 828 0096 1A70     		strb	r2, [r3]
 423:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for transmitting */
 829              		.loc 1 423 0
 830 0098 7B69     		ldr	r3, [r7, #20]
 831 009a BA68     		ldr	r2, [r7, #8]
 832 009c 1A61     		str	r2, [r3, #16]
 424:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutLenM = Size;       /* Set the counter of output bufer's content */
 833              		.loc 1 424 0
 834 009e 7B69     		ldr	r3, [r7, #20]
 835 00a0 BA1D     		add	r2, r7, #6
 836 00a2 1288     		ldrh	r2, [r2]
 837 00a4 9A81     		strh	r2, [r3, #12]
 425:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 838              		.loc 1 425 0
 839 00a6 7B69     		ldr	r3, [r7, #20]
 840 00a8 7A1D     		add	r2, r7, #5
 841 00aa 1278     		ldrb	r2, [r2]
 842 00ac 5A70     		strb	r2, [r3, #1]
 426:../Generated_Code/I2C2.c ****   I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 843              		.loc 1 426 0
 844 00ae 354B     		ldr	r3, .L39
 845 00b0 344A     		ldr	r2, .L39
 846 00b2 9278     		ldrb	r2, [r2, #2]
 847 00b4 D2B2     		uxtb	r2, r2
 848 00b6 D2B2     		uxtb	r2, r2
 849 00b8 1021     		mov	r1, #16
 850 00ba 0A43     		orr	r2, r1
 851 00bc D2B2     		uxtb	r2, r2
 852 00be D2B2     		uxtb	r2, r2
 853 00c0 9A70     		strb	r2, [r3, #2]
 427:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 854              		.loc 1 427 0
 855 00c2 304B     		ldr	r3, .L39
 856 00c4 9B78     		ldrb	r3, [r3, #2]
 857 00c6 DBB2     		uxtb	r3, r3
 858 00c8 1A1C     		mov	r2, r3
 859 00ca 2023     		mov	r3, #32
 860 00cc 1340     		and	r3, r2
 861 00ce 08D0     		beq	.L33
 428:../Generated_Code/I2C2.c ****     I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* If yes then repeat start cycle generated */
 862              		.loc 1 428 0
 863 00d0 2C4B     		ldr	r3, .L39
 864 00d2 2C4A     		ldr	r2, .L39
 865 00d4 9278     		ldrb	r2, [r2, #2]
 866 00d6 D2B2     		uxtb	r2, r2
 867 00d8 0421     		mov	r1, #4
 868 00da 0A43     		orr	r2, r1
 869 00dc D2B2     		uxtb	r2, r2
 870 00de 9A70     		strb	r2, [r3, #2]
 871 00e0 09E0     		b	.L34
 872              	.L33:
 429:../Generated_Code/I2C2.c ****   } else {
 430:../Generated_Code/I2C2.c ****     I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 873              		.loc 1 430 0
 874 00e2 284B     		ldr	r3, .L39
 875 00e4 274A     		ldr	r2, .L39
 876 00e6 9278     		ldrb	r2, [r2, #2]
 877 00e8 D2B2     		uxtb	r2, r2
 878 00ea D2B2     		uxtb	r2, r2
 879 00ec 2021     		mov	r1, #32
 880 00ee 0A43     		orr	r2, r1
 881 00f0 D2B2     		uxtb	r2, r2
 882 00f2 D2B2     		uxtb	r2, r2
 883 00f4 9A70     		strb	r2, [r3, #2]
 884              	.L34:
 431:../Generated_Code/I2C2.c ****   }
 432:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 885              		.loc 1 432 0
 886 00f6 7B69     		ldr	r3, [r7, #20]
 887 00f8 1B78     		ldrb	r3, [r3]
 888 00fa 1A1C     		mov	r2, r3
 889 00fc 2023     		mov	r3, #32
 890 00fe 1340     		and	r3, r2
 891 0100 0BD0     		beq	.L35
 433:../Generated_Code/I2C2.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Only one byte of address will
 892              		.loc 1 433 0
 893 0102 7B69     		ldr	r3, [r7, #20]
 894 0104 1B78     		ldrb	r3, [r3]
 895 0106 0622     		mov	r2, #6
 896 0108 1343     		orr	r3, r2
 897 010a DAB2     		uxtb	r2, r3
 898 010c 7B69     		ldr	r3, [r7, #20]
 899 010e 1A70     		strb	r2, [r3]
 434:../Generated_Code/I2C2.c ****     I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send slave address */
 900              		.loc 1 434 0
 901 0110 1C4B     		ldr	r3, .L39
 902 0112 7A69     		ldr	r2, [r7, #20]
 903 0114 1279     		ldrb	r2, [r2, #4]
 904 0116 1A71     		strb	r2, [r3, #4]
 905 0118 21E0     		b	.L36
 906              	.L35:
 435:../Generated_Code/I2C2.c ****   } else {
 436:../Generated_Code/I2C2.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 907              		.loc 1 436 0
 908 011a 7B69     		ldr	r3, [r7, #20]
 909 011c 1B78     		ldrb	r3, [r3]
 910 011e 1A1C     		mov	r2, r3
 911 0120 1023     		mov	r3, #16
 912 0122 1340     		and	r3, r2
 913 0124 0BD0     		beq	.L37
 437:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 914              		.loc 1 437 0
 915 0126 7B69     		ldr	r3, [r7, #20]
 916 0128 1B78     		ldrb	r3, [r3]
 917 012a 0622     		mov	r2, #6
 918 012c 9343     		bic	r3, r2
 919 012e DAB2     		uxtb	r2, r3
 920 0130 7B69     		ldr	r3, [r7, #20]
 921 0132 1A70     		strb	r2, [r3]
 438:../Generated_Code/I2C2.c ****       I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 922              		.loc 1 438 0
 923 0134 134B     		ldr	r3, .L39
 924 0136 7A69     		ldr	r2, [r7, #20]
 925 0138 5279     		ldrb	r2, [r2, #5]
 926 013a 1A71     		strb	r2, [r3, #4]
 927 013c 0FE0     		b	.L36
 928              	.L37:
 439:../Generated_Code/I2C2.c ****     } else {
 440:../Generated_Code/I2C2.c ****       if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is general call command required ?
 929              		.loc 1 440 0
 930 013e 7B69     		ldr	r3, [r7, #20]
 931 0140 1B78     		ldrb	r3, [r3]
 932 0142 1A1C     		mov	r2, r3
 933 0144 0823     		mov	r3, #8
 934 0146 1340     		and	r3, r2
 935 0148 09D0     		beq	.L36
 441:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag |= ADDR_COMPLETE; /* Only one byte of address will be sent in genera
 936              		.loc 1 441 0
 937 014a 7B69     		ldr	r3, [r7, #20]
 938 014c 1B78     		ldrb	r3, [r3]
 939 014e 0222     		mov	r2, #2
 940 0150 1343     		orr	r3, r2
 941 0152 DAB2     		uxtb	r2, r3
 942 0154 7B69     		ldr	r3, [r7, #20]
 943 0156 1A70     		strb	r2, [r3]
 442:../Generated_Code/I2C2.c ****         I2C_PDD_WriteDataReg(I2C0_BASE_PTR, 0x00U); /* Send general call address */
 944              		.loc 1 442 0
 945 0158 0A4B     		ldr	r3, .L39
 946 015a 0022     		mov	r2, #0
 947 015c 1A71     		strb	r2, [r3, #4]
 948              	.L36:
 443:../Generated_Code/I2C2.c ****       }
 444:../Generated_Code/I2C2.c ****     }
 445:../Generated_Code/I2C2.c ****   }
 446:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 447:../Generated_Code/I2C2.c ****   ExitCritical();
 949              		.loc 1 447 0
 950 015e 0A4B     		ldr	r3, .L39+4
 951 0160 1B78     		ldrb	r3, [r3]
 952 0162 DBB2     		uxtb	r3, r3
 953 0164 013B     		sub	r3, r3, #1
 954 0166 DBB2     		uxtb	r3, r3
 955 0168 074A     		ldr	r2, .L39+4
 956 016a 191C     		add	r1, r3, #0
 957 016c 1170     		strb	r1, [r2]
 958 016e 002B     		cmp	r3, #0
 959 0170 03D1     		bne	.L38
 960              		.loc 1 447 0 is_stmt 0
 961 0172 064B     		ldr	r3, .L39+8
 962              	@ 447 "../Generated_Code/I2C2.c" 1
 963 0174 1878     		ldrb r0, [r3]
 964 0176 80F31088 		msr PRIMASK,r0;
 965              		
 966              	@ 0 "" 2
 967              		.code	16
 968              	.L38:
 448:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 969              		.loc 1 448 0 is_stmt 1
 970 017a 0023     		mov	r3, #0
 971              	.L27:
 449:../Generated_Code/I2C2.c **** }
 972              		.loc 1 449 0
 973 017c 181C     		mov	r0, r3
 974 017e BD46     		mov	sp, r7
 975 0180 06B0     		add	sp, sp, #24
 976              		@ sp needed for prologue
 977 0182 80BD     		pop	{r7, pc}
 978              	.L40:
 979              		.align	2
 980              	.L39:
 981 0184 00600640 		.word	1074159616
 982 0188 00000000 		.word	SR_lock
 983 018c 00000000 		.word	SR_reg
 984              		.cfi_endproc
 985              	.LFE3:
 987              		.section	.text.I2C2_MasterReceiveBlock,"ax",%progbits
 988              		.align	2
 989              		.global	I2C2_MasterReceiveBlock
 990              		.code	16
 991              		.thumb_func
 993              	I2C2_MasterReceiveBlock:
 994              	.LFB4:
 450:../Generated_Code/I2C2.c **** 
 451:../Generated_Code/I2C2.c **** /*
 452:../Generated_Code/I2C2.c **** ** ===================================================================
 453:../Generated_Code/I2C2.c **** **     Method      :  I2C2_MasterReceiveBlock (component I2C_LDD)
 454:../Generated_Code/I2C2.c **** **
 455:../Generated_Code/I2C2.c **** **     Description :
 456:../Generated_Code/I2C2.c **** **         This method writes one (7-bit addressing) or two (10-bit
 457:../Generated_Code/I2C2.c **** **         addressing) slave address bytes inclusive of R/W bit = 1 to
 458:../Generated_Code/I2C2.c **** **         the I2C bus and then receives the block of characters from
 459:../Generated_Code/I2C2.c **** **         the bus. The slave address must be specified before, by the
 460:../Generated_Code/I2C2.c **** **         "SelectSlaveDevice" method or in component initialization
 461:../Generated_Code/I2C2.c **** **         section, "Target slave address init" property. If the method
 462:../Generated_Code/I2C2.c **** **         returns ERR_OK, it doesn't mean that reception was
 463:../Generated_Code/I2C2.c **** **         successful. The state of reception is detectable by means of
 464:../Generated_Code/I2C2.c **** **         events (OnMasterSendComplete  or OnError). Data to be
 465:../Generated_Code/I2C2.c **** **         received are not copied to an internal buffer and remains in
 466:../Generated_Code/I2C2.c **** **         the original location. Therefore the content of the buffer
 467:../Generated_Code/I2C2.c **** **         should not be changed until the transmission is complete.
 468:../Generated_Code/I2C2.c **** **         Event "OnMasterBlockReceived"can be used to detect the end
 469:../Generated_Code/I2C2.c **** **         of the reception. This method is available only for the
 470:../Generated_Code/I2C2.c **** **         MASTER or MASTER - SLAVE mode.
 471:../Generated_Code/I2C2.c **** **     Parameters  :
 472:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 473:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 474:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 475:../Generated_Code/I2C2.c **** **       * BufferPtr       - Pointer to a buffer where
 476:../Generated_Code/I2C2.c **** **                           received characters will be stored.
 477:../Generated_Code/I2C2.c **** **         Size            - The size of the block.
 478:../Generated_Code/I2C2.c **** **         SendStop        - Parameter for generating I2C
 479:../Generated_Code/I2C2.c **** **                           Stop condition
 480:../Generated_Code/I2C2.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 481:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 482:../Generated_Code/I2C2.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 483:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 484:../Generated_Code/I2C2.c **** **     Returns     :
 485:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 486:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 487:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 488:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 489:../Generated_Code/I2C2.c **** **                           the active clock configuration
 490:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The master device is busy
 491:../Generated_Code/I2C2.c **** **                           ERR_NOTAVAIL - It is not possible to
 492:../Generated_Code/I2C2.c **** **                           receive data if general call address is set.
 493:../Generated_Code/I2C2.c **** **                           ERR_PARAM_MODE -  Stop condition isn't
 494:../Generated_Code/I2C2.c **** **                           possible generated on end transmission.
 495:../Generated_Code/I2C2.c **** ** ===================================================================
 496:../Generated_Code/I2C2.c **** */
 497:../Generated_Code/I2C2.c **** LDD_TError I2C2_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TS
 498:../Generated_Code/I2C2.c **** {
 995              		.loc 1 498 0
 996              		.cfi_startproc
 997 0000 80B5     		push	{r7, lr}
 998              	.LCFI12:
 999              		.cfi_def_cfa_offset 8
 1000              		.cfi_offset 7, -8
 1001              		.cfi_offset 14, -4
 1002 0002 86B0     		sub	sp, sp, #24
 1003              	.LCFI13:
 1004              		.cfi_def_cfa_offset 32
 1005 0004 00AF     		add	r7, sp, #0
 1006              	.LCFI14:
 1007              		.cfi_def_cfa_register 7
 1008 0006 F860     		str	r0, [r7, #12]
 1009 0008 B960     		str	r1, [r7, #8]
 1010 000a 111C     		mov	r1, r2
 1011 000c 1A1C     		mov	r2, r3
 1012 000e BB1D     		add	r3, r7, #6
 1013 0010 1980     		strh	r1, [r3]
 1014 0012 7B1D     		add	r3, r7, #5
 1015 0014 1A70     		strb	r2, [r3]
 499:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1016              		.loc 1 499 0
 1017 0016 FB68     		ldr	r3, [r7, #12]
 1018 0018 7B61     		str	r3, [r7, #20]
 500:../Generated_Code/I2C2.c **** 
 501:../Generated_Code/I2C2.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 1019              		.loc 1 501 0
 1020 001a BB1D     		add	r3, r7, #6
 1021 001c 1B88     		ldrh	r3, [r3]
 1022 001e 002B     		cmp	r3, #0
 1023 0020 01D1     		bne	.L42
 502:../Generated_Code/I2C2.c ****     return ERR_OK;                     /* If zero then OK */
 1024              		.loc 1 502 0
 1025 0022 0023     		mov	r3, #0
 1026 0024 AAE0     		b	.L43
 1027              	.L42:
 503:../Generated_Code/I2C2.c ****   }
 504:../Generated_Code/I2C2.c ****   if (SendStop == LDD_I2C_NO_SEND_STOP) { /* Test variable SendStop on supported value */
 1028              		.loc 1 504 0
 1029 0026 7B1D     		add	r3, r7, #5
 1030 0028 1B78     		ldrb	r3, [r3]
 1031 002a 002B     		cmp	r3, #0
 1032 002c 01D1     		bne	.L44
 505:../Generated_Code/I2C2.c ****     return ERR_PARAM_MODE;             /* If not supported value then error */
 1033              		.loc 1 505 0
 1034 002e 8123     		mov	r3, #129
 1035 0030 A4E0     		b	.L43
 1036              	.L44:
 506:../Generated_Code/I2C2.c ****   }
 507:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is the general call flag set (SelectSl
 1037              		.loc 1 507 0
 1038 0032 7B69     		ldr	r3, [r7, #20]
 1039 0034 1B78     		ldrb	r3, [r3]
 1040 0036 1A1C     		mov	r2, r3
 1041 0038 0823     		mov	r3, #8
 1042 003a 1340     		and	r3, r2
 1043 003c 01D0     		beq	.L45
 508:../Generated_Code/I2C2.c ****     return ERR_NOTAVAIL;               /* It is not possible to receive data - Call SelectSlaveDevi
 1044              		.loc 1 508 0
 1045 003e 0923     		mov	r3, #9
 1046 0040 9CE0     		b	.L43
 1047              	.L45:
 509:../Generated_Code/I2C2.c ****   }
 510:../Generated_Code/I2C2.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 1048              		.loc 1 510 0
 1049 0042 7B69     		ldr	r3, [r7, #20]
 1050 0044 5B78     		ldrb	r3, [r3, #1]
 1051 0046 012B     		cmp	r3, #1
 1052 0048 12D1     		bne	.L46
 511:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1053              		.loc 1 511 0
 1054 004a 4E4B     		ldr	r3, .L56
 1055 004c DB78     		ldrb	r3, [r3, #3]
 1056 004e DBB2     		uxtb	r3, r3
 1057 0050 1A1C     		mov	r2, r3
 1058 0052 2023     		mov	r3, #32
 1059 0054 1340     		and	r3, r2
 1060 0056 09D1     		bne	.L47
 512:../Generated_Code/I2C2.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 1061              		.loc 1 512 0
 1062 0058 7B69     		ldr	r3, [r7, #20]
 1063 005a 1B78     		ldrb	r3, [r3]
 1064 005c 1A1C     		mov	r2, r3
 1065 005e 0123     		mov	r3, #1
 1066 0060 1340     		and	r3, r2
 511:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1067              		.loc 1 511 0
 1068 0062 03D1     		bne	.L47
 513:../Generated_Code/I2C2.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 1069              		.loc 1 513 0
 1070 0064 7B69     		ldr	r3, [r7, #20]
 1071 0066 DB88     		ldrh	r3, [r3, #6]
 512:../Generated_Code/I2C2.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 1072              		.loc 1 512 0
 1073 0068 002B     		cmp	r3, #0
 1074 006a 0DD0     		beq	.L48
 1075              	.L47:
 514:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 1076              		.loc 1 514 0
 1077 006c 0823     		mov	r3, #8
 1078 006e 85E0     		b	.L43
 1079              	.L46:
 515:../Generated_Code/I2C2.c ****     }
 516:../Generated_Code/I2C2.c ****   } else {
 517:../Generated_Code/I2C2.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1080              		.loc 1 517 0
 1081 0070 7B69     		ldr	r3, [r7, #20]
 1082 0072 1B78     		ldrb	r3, [r3]
 1083 0074 1A1C     		mov	r2, r3
 1084 0076 0123     		mov	r3, #1
 1085 0078 1340     		and	r3, r2
 1086 007a 03D1     		bne	.L49
 518:../Generated_Code/I2C2.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 1087              		.loc 1 518 0
 1088 007c 7B69     		ldr	r3, [r7, #20]
 1089 007e DB88     		ldrh	r3, [r3, #6]
 517:../Generated_Code/I2C2.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1090              		.loc 1 517 0
 1091 0080 002B     		cmp	r3, #0
 1092 0082 01D0     		beq	.L48
 1093              	.L49:
 519:../Generated_Code/I2C2.c ****       return ERR_BUSY;               /* If yes then error */
 1094              		.loc 1 519 0
 1095 0084 0823     		mov	r3, #8
 1096 0086 79E0     		b	.L43
 1097              	.L48:
 520:../Generated_Code/I2C2.c ****     }
 521:../Generated_Code/I2C2.c ****   }
 522:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 523:../Generated_Code/I2C2.c ****   EnterCritical();
 1098              		.loc 1 523 0
 1099 0088 3F4B     		ldr	r3, .L56+4
 1100 008a 1B78     		ldrb	r3, [r3]
 1101 008c DBB2     		uxtb	r3, r3
 1102 008e 0133     		add	r3, r3, #1
 1103 0090 DBB2     		uxtb	r3, r3
 1104 0092 3D4A     		ldr	r2, .L56+4
 1105 0094 191C     		add	r1, r3, #0
 1106 0096 1170     		strb	r1, [r2]
 1107 0098 012B     		cmp	r3, #1
 1108 009a 04D1     		bne	.L50
 1109              		.loc 1 523 0 is_stmt 0
 1110 009c 3B4B     		ldr	r3, .L56+8
 1111              	@ 523 "../Generated_Code/I2C2.c" 1
 1112 009e EFF31080 		MRS R0, PRIMASK
 1113 00a2 72B6     		CPSID i
 1114 00a4 1870     		STRB R0, [r3]
 1115              	@ 0 "" 2
 1116              		.code	16
 1117              	.L50:
 524:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 1118              		.loc 1 524 0 is_stmt 1
 1119 00a6 7B69     		ldr	r3, [r7, #20]
 1120 00a8 1B78     		ldrb	r3, [r3]
 1121 00aa 0122     		mov	r2, #1
 1122 00ac 1343     		orr	r3, r2
 1123 00ae DAB2     		uxtb	r2, r3
 1124 00b0 7B69     		ldr	r3, [r7, #20]
 1125 00b2 1A70     		strb	r2, [r3]
 525:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for reception */
 1126              		.loc 1 525 0
 1127 00b4 7B69     		ldr	r3, [r7, #20]
 1128 00b6 BA68     		ldr	r2, [r7, #8]
 1129 00b8 9A60     		str	r2, [r3, #8]
 526:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpLenM = Size;       /* Set the counter of input bufer's content */
 1130              		.loc 1 526 0
 1131 00ba 7B69     		ldr	r3, [r7, #20]
 1132 00bc BA1D     		add	r2, r7, #6
 1133 00be 1288     		ldrh	r2, [r2]
 1134 00c0 DA80     		strh	r2, [r3, #6]
 527:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 1135              		.loc 1 527 0
 1136 00c2 7B69     		ldr	r3, [r7, #20]
 1137 00c4 7A1D     		add	r2, r7, #5
 1138 00c6 1278     		ldrb	r2, [r2]
 1139 00c8 5A70     		strb	r2, [r3, #1]
 528:../Generated_Code/I2C2.c ****   I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 1140              		.loc 1 528 0
 1141 00ca 2E4B     		ldr	r3, .L56
 1142 00cc 2D4A     		ldr	r2, .L56
 1143 00ce 9278     		ldrb	r2, [r2, #2]
 1144 00d0 D2B2     		uxtb	r2, r2
 1145 00d2 D2B2     		uxtb	r2, r2
 1146 00d4 1021     		mov	r1, #16
 1147 00d6 0A43     		orr	r2, r1
 1148 00d8 D2B2     		uxtb	r2, r2
 1149 00da D2B2     		uxtb	r2, r2
 1150 00dc 9A70     		strb	r2, [r3, #2]
 529:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 1151              		.loc 1 529 0
 1152 00de 294B     		ldr	r3, .L56
 1153 00e0 9B78     		ldrb	r3, [r3, #2]
 1154 00e2 DBB2     		uxtb	r3, r3
 1155 00e4 1A1C     		mov	r2, r3
 1156 00e6 2023     		mov	r3, #32
 1157 00e8 1340     		and	r3, r2
 1158 00ea 08D0     		beq	.L51
 530:../Generated_Code/I2C2.c ****     I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* If yes then repeat start cycle generated */
 1159              		.loc 1 530 0
 1160 00ec 254B     		ldr	r3, .L56
 1161 00ee 254A     		ldr	r2, .L56
 1162 00f0 9278     		ldrb	r2, [r2, #2]
 1163 00f2 D2B2     		uxtb	r2, r2
 1164 00f4 0421     		mov	r1, #4
 1165 00f6 0A43     		orr	r2, r1
 1166 00f8 D2B2     		uxtb	r2, r2
 1167 00fa 9A70     		strb	r2, [r3, #2]
 1168 00fc 09E0     		b	.L52
 1169              	.L51:
 531:../Generated_Code/I2C2.c ****   } else {
 532:../Generated_Code/I2C2.c ****     I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 1170              		.loc 1 532 0
 1171 00fe 214B     		ldr	r3, .L56
 1172 0100 204A     		ldr	r2, .L56
 1173 0102 9278     		ldrb	r2, [r2, #2]
 1174 0104 D2B2     		uxtb	r2, r2
 1175 0106 D2B2     		uxtb	r2, r2
 1176 0108 2021     		mov	r1, #32
 1177 010a 0A43     		orr	r2, r1
 1178 010c D2B2     		uxtb	r2, r2
 1179 010e D2B2     		uxtb	r2, r2
 1180 0110 9A70     		strb	r2, [r3, #2]
 1181              	.L52:
 533:../Generated_Code/I2C2.c ****   }
 534:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 1182              		.loc 1 534 0
 1183 0112 7B69     		ldr	r3, [r7, #20]
 1184 0114 1B78     		ldrb	r3, [r3]
 1185 0116 1A1C     		mov	r2, r3
 1186 0118 2023     		mov	r3, #32
 1187 011a 1340     		and	r3, r2
 1188 011c 0ED0     		beq	.L53
 535:../Generated_Code/I2C2.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE|REP_ADDR_COMPLETE); /* Only one byte of address will b
 1189              		.loc 1 535 0
 1190 011e 7B69     		ldr	r3, [r7, #20]
 1191 0120 1B78     		ldrb	r3, [r3]
 1192 0122 0622     		mov	r2, #6
 1193 0124 1343     		orr	r3, r2
 1194 0126 DAB2     		uxtb	r2, r3
 1195 0128 7B69     		ldr	r3, [r7, #20]
 1196 012a 1A70     		strb	r2, [r3]
 536:../Generated_Code/I2C2.c ****     I2C_PDD_WriteDataReg(I2C0_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddr | 0x01U)); /* Send slave
 1197              		.loc 1 536 0
 1198 012c 154B     		ldr	r3, .L56
 1199 012e 7A69     		ldr	r2, [r7, #20]
 1200 0130 1279     		ldrb	r2, [r2, #4]
 1201 0132 0121     		mov	r1, #1
 1202 0134 0A43     		orr	r2, r1
 1203 0136 D2B2     		uxtb	r2, r2
 1204 0138 1A71     		strb	r2, [r3, #4]
 1205 013a 10E0     		b	.L54
 1206              	.L53:
 537:../Generated_Code/I2C2.c ****   } else {
 538:../Generated_Code/I2C2.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 1207              		.loc 1 538 0
 1208 013c 7B69     		ldr	r3, [r7, #20]
 1209 013e 1B78     		ldrb	r3, [r3]
 1210 0140 1A1C     		mov	r2, r3
 1211 0142 1023     		mov	r3, #16
 1212 0144 1340     		and	r3, r2
 1213 0146 0AD0     		beq	.L54
 539:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 1214              		.loc 1 539 0
 1215 0148 7B69     		ldr	r3, [r7, #20]
 1216 014a 1B78     		ldrb	r3, [r3]
 1217 014c 0622     		mov	r2, #6
 1218 014e 9343     		bic	r3, r2
 1219 0150 DAB2     		uxtb	r2, r3
 1220 0152 7B69     		ldr	r3, [r7, #20]
 1221 0154 1A70     		strb	r2, [r3]
 540:../Generated_Code/I2C2.c ****       I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 1222              		.loc 1 540 0
 1223 0156 0B4B     		ldr	r3, .L56
 1224 0158 7A69     		ldr	r2, [r7, #20]
 1225 015a 5279     		ldrb	r2, [r2, #5]
 1226 015c 1A71     		strb	r2, [r3, #4]
 1227              	.L54:
 541:../Generated_Code/I2C2.c ****     }
 542:../Generated_Code/I2C2.c ****   }
 543:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 544:../Generated_Code/I2C2.c ****   ExitCritical();
 1228              		.loc 1 544 0
 1229 015e 0A4B     		ldr	r3, .L56+4
 1230 0160 1B78     		ldrb	r3, [r3]
 1231 0162 DBB2     		uxtb	r3, r3
 1232 0164 013B     		sub	r3, r3, #1
 1233 0166 DBB2     		uxtb	r3, r3
 1234 0168 074A     		ldr	r2, .L56+4
 1235 016a 191C     		add	r1, r3, #0
 1236 016c 1170     		strb	r1, [r2]
 1237 016e 002B     		cmp	r3, #0
 1238 0170 03D1     		bne	.L55
 1239              		.loc 1 544 0 is_stmt 0
 1240 0172 064B     		ldr	r3, .L56+8
 1241              	@ 544 "../Generated_Code/I2C2.c" 1
 1242 0174 1878     		ldrb r0, [r3]
 1243 0176 80F31088 		msr PRIMASK,r0;
 1244              		
 1245              	@ 0 "" 2
 1246              		.code	16
 1247              	.L55:
 545:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 1248              		.loc 1 545 0 is_stmt 1
 1249 017a 0023     		mov	r3, #0
 1250              	.L43:
 546:../Generated_Code/I2C2.c **** }
 1251              		.loc 1 546 0
 1252 017c 181C     		mov	r0, r3
 1253 017e BD46     		mov	sp, r7
 1254 0180 06B0     		add	sp, sp, #24
 1255              		@ sp needed for prologue
 1256 0182 80BD     		pop	{r7, pc}
 1257              	.L57:
 1258              		.align	2
 1259              	.L56:
 1260 0184 00600640 		.word	1074159616
 1261 0188 00000000 		.word	SR_lock
 1262 018c 00000000 		.word	SR_reg
 1263              		.cfi_endproc
 1264              	.LFE4:
 1266              		.section	.text.I2C2_SelectSlaveDevice,"ax",%progbits
 1267              		.align	2
 1268              		.global	I2C2_SelectSlaveDevice
 1269              		.code	16
 1270              		.thumb_func
 1272              	I2C2_SelectSlaveDevice:
 1273              	.LFB5:
 547:../Generated_Code/I2C2.c **** 
 548:../Generated_Code/I2C2.c **** /*
 549:../Generated_Code/I2C2.c **** ** ===================================================================
 550:../Generated_Code/I2C2.c **** **     Method      :  I2C2_SelectSlaveDevice (component I2C_LDD)
 551:../Generated_Code/I2C2.c **** **
 552:../Generated_Code/I2C2.c **** **     Description :
 553:../Generated_Code/I2C2.c **** **         This method selects a new slave for communication by its
 554:../Generated_Code/I2C2.c **** **         7-bit slave, 10-bit address or general call value. Any send
 555:../Generated_Code/I2C2.c **** **         or receive method directs to or from selected device, until
 556:../Generated_Code/I2C2.c **** **         a new slave device is selected by this method. This method
 557:../Generated_Code/I2C2.c **** **         is available for the MASTER mode.
 558:../Generated_Code/I2C2.c **** **     Parameters  :
 559:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 560:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 561:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 562:../Generated_Code/I2C2.c **** **         AddrType        - Specify type of slave address
 563:../Generated_Code/I2C2.c **** **                           (7bit, 10bit or general call address), e.g.
 564:../Generated_Code/I2C2.c **** **                           LDD_I2C_ADDRTYPE_7BITS.
 565:../Generated_Code/I2C2.c **** **         Addr            - 7bit or 10bit slave address value.
 566:../Generated_Code/I2C2.c **** **     Returns     :
 567:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 568:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 569:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The device is busy, wait until
 570:../Generated_Code/I2C2.c **** **                           the current operation is finished.
 571:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  The device is disabled.
 572:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 573:../Generated_Code/I2C2.c **** **                           the active clock configuration
 574:../Generated_Code/I2C2.c **** **                           ERR_PARAM_ADDRESS_TYPE -  Invalid address
 575:../Generated_Code/I2C2.c **** **                           type.
 576:../Generated_Code/I2C2.c **** **                           ERR_PARAM_ADDRESS -  Invalid address value.
 577:../Generated_Code/I2C2.c **** ** ===================================================================
 578:../Generated_Code/I2C2.c **** */
 579:../Generated_Code/I2C2.c **** LDD_TError I2C2_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TAddrType AddrType, LDD_I
 580:../Generated_Code/I2C2.c **** {
 1274              		.loc 1 580 0
 1275              		.cfi_startproc
 1276 0000 80B5     		push	{r7, lr}
 1277              	.LCFI15:
 1278              		.cfi_def_cfa_offset 8
 1279              		.cfi_offset 7, -8
 1280              		.cfi_offset 14, -4
 1281 0002 84B0     		sub	sp, sp, #16
 1282              	.LCFI16:
 1283              		.cfi_def_cfa_offset 24
 1284 0004 00AF     		add	r7, sp, #0
 1285              	.LCFI17:
 1286              		.cfi_def_cfa_register 7
 1287 0006 7860     		str	r0, [r7, #4]
 1288 0008 FB1C     		add	r3, r7, #3
 1289 000a 1970     		strb	r1, [r3]
 1290 000c 3B1C     		mov	r3, r7
 1291 000e 1A80     		strh	r2, [r3]
 581:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1292              		.loc 1 581 0
 1293 0010 7B68     		ldr	r3, [r7, #4]
 1294 0012 FB60     		str	r3, [r7, #12]
 582:../Generated_Code/I2C2.c **** 
 583:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) { /* Is the device in the active state
 1295              		.loc 1 583 0
 1296 0014 FB68     		ldr	r3, [r7, #12]
 1297 0016 1B78     		ldrb	r3, [r3]
 1298 0018 1A1C     		mov	r2, r3
 1299 001a 0123     		mov	r3, #1
 1300 001c 1340     		and	r3, r2
 1301 001e 01D0     		beq	.L59
 584:../Generated_Code/I2C2.c ****     return ERR_BUSY;                   /* If yes then error */
 1302              		.loc 1 584 0
 1303 0020 0823     		mov	r3, #8
 1304 0022 66E0     		b	.L60
 1305              	.L59:
 585:../Generated_Code/I2C2.c ****   }
 586:../Generated_Code/I2C2.c ****   switch (AddrType) {
 1306              		.loc 1 586 0
 1307 0024 FB1C     		add	r3, r7, #3
 1308 0026 1B78     		ldrb	r3, [r3]
 1309 0028 012B     		cmp	r3, #1
 1310 002a 1FD0     		beq	.L63
 1311 002c 022B     		cmp	r3, #2
 1312 002e 4ED0     		beq	.L64
 1313 0030 002B     		cmp	r3, #0
 1314 0032 5BD1     		bne	.L68
 1315              	.L62:
 587:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_7BITS:
 588:../Generated_Code/I2C2.c ****       if (Addr > 0x7FU) {              /* Test address value */
 1316              		.loc 1 588 0
 1317 0034 3B1C     		mov	r3, r7
 1318 0036 1B88     		ldrh	r3, [r3]
 1319 0038 7F2B     		cmp	r3, #127
 1320 003a 01D9     		bls	.L65
 589:../Generated_Code/I2C2.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 1321              		.loc 1 589 0
 1322 003c 8923     		mov	r3, #137
 1323 003e 58E0     		b	.L60
 1324              	.L65:
 590:../Generated_Code/I2C2.c ****       }
 591:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)((uint8_t)Addr << 0x01U); /* Set slave address */
 1325              		.loc 1 591 0
 1326 0040 3B1C     		mov	r3, r7
 1327 0042 1B88     		ldrh	r3, [r3]
 1328 0044 DBB2     		uxtb	r3, r3
 1329 0046 5B00     		lsl	r3, r3, #1
 1330 0048 DAB2     		uxtb	r2, r3
 1331 004a FB68     		ldr	r3, [r7, #12]
 1332 004c 1A71     		strb	r2, [r3, #4]
 592:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_10); /* Clear the general call flag 
 1333              		.loc 1 592 0
 1334 004e FB68     		ldr	r3, [r7, #12]
 1335 0050 1B78     		ldrb	r3, [r3]
 1336 0052 1822     		mov	r2, #24
 1337 0054 9343     		bic	r3, r2
 1338 0056 DAB2     		uxtb	r2, r3
 1339 0058 FB68     		ldr	r3, [r7, #12]
 1340 005a 1A70     		strb	r2, [r3]
 593:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= ADDR_7; /* Set 7-bit address mode flag */
 1341              		.loc 1 593 0
 1342 005c FB68     		ldr	r3, [r7, #12]
 1343 005e 1B78     		ldrb	r3, [r3]
 1344 0060 2022     		mov	r2, #32
 1345 0062 1343     		orr	r3, r2
 1346 0064 DAB2     		uxtb	r2, r3
 1347 0066 FB68     		ldr	r3, [r7, #12]
 1348 0068 1A70     		strb	r2, [r3]
 594:../Generated_Code/I2C2.c ****     break;
 1349              		.loc 1 594 0
 1350 006a 41E0     		b	.L66
 1351              	.L63:
 595:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_10BITS:
 596:../Generated_Code/I2C2.c ****       if (Addr > 0x03FFU) {            /* Test address value */
 1352              		.loc 1 596 0
 1353 006c 3B1C     		mov	r3, r7
 1354 006e 1A88     		ldrh	r2, [r3]
 1355 0070 224B     		ldr	r3, .L69
 1356 0072 9A42     		cmp	r2, r3
 1357 0074 01D9     		bls	.L67
 597:../Generated_Code/I2C2.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 1358              		.loc 1 597 0
 1359 0076 8923     		mov	r3, #137
 1360 0078 3BE0     		b	.L60
 1361              	.L67:
 598:../Generated_Code/I2C2.c ****       }
 599:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)Addr; /* Set slave address - low byte */
 1362              		.loc 1 599 0
 1363 007a 3B1C     		mov	r3, r7
 1364 007c 1B88     		ldrh	r3, [r3]
 1365 007e DAB2     		uxtb	r2, r3
 1366 0080 FB68     		ldr	r3, [r7, #12]
 1367 0082 1A71     		strb	r2, [r3, #4]
 600:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh = (uint8_t)((uint16_t)Addr >> 0x07U); /* Set slave address - hig
 1368              		.loc 1 600 0
 1369 0084 3B1C     		mov	r3, r7
 1370 0086 1B88     		ldrh	r3, [r3]
 1371 0088 DB09     		lsr	r3, r3, #7
 1372 008a 9BB2     		uxth	r3, r3
 1373 008c DAB2     		uxtb	r2, r3
 1374 008e FB68     		ldr	r3, [r7, #12]
 1375 0090 5A71     		strb	r2, [r3, #5]
 601:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh &= 0x06U; /* Format address to 11110xx0 */
 1376              		.loc 1 601 0
 1377 0092 FB68     		ldr	r3, [r7, #12]
 1378 0094 5A79     		ldrb	r2, [r3, #5]
 1379 0096 0623     		mov	r3, #6
 1380 0098 1340     		and	r3, r2
 1381 009a DAB2     		uxtb	r2, r3
 1382 009c FB68     		ldr	r3, [r7, #12]
 1383 009e 5A71     		strb	r2, [r3, #5]
 602:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh |= 0xF0U;
 1384              		.loc 1 602 0
 1385 00a0 FB68     		ldr	r3, [r7, #12]
 1386 00a2 5B79     		ldrb	r3, [r3, #5]
 1387 00a4 1022     		mov	r2, #16
 1388 00a6 5242     		neg	r2, r2
 1389 00a8 1343     		orr	r3, r2
 1390 00aa DAB2     		uxtb	r2, r3
 1391 00ac FB68     		ldr	r3, [r7, #12]
 1392 00ae 5A71     		strb	r2, [r3, #5]
 603:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_7); /* Clear the general call flag a
 1393              		.loc 1 603 0
 1394 00b0 FB68     		ldr	r3, [r7, #12]
 1395 00b2 1B78     		ldrb	r3, [r3]
 1396 00b4 2822     		mov	r2, #40
 1397 00b6 9343     		bic	r3, r2
 1398 00b8 DAB2     		uxtb	r2, r3
 1399 00ba FB68     		ldr	r3, [r7, #12]
 1400 00bc 1A70     		strb	r2, [r3]
 604:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= ADDR_10; /* Set 10-bit address mode flag */
 1401              		.loc 1 604 0
 1402 00be FB68     		ldr	r3, [r7, #12]
 1403 00c0 1B78     		ldrb	r3, [r3]
 1404 00c2 1022     		mov	r2, #16
 1405 00c4 1343     		orr	r3, r2
 1406 00c6 DAB2     		uxtb	r2, r3
 1407 00c8 FB68     		ldr	r3, [r7, #12]
 1408 00ca 1A70     		strb	r2, [r3]
 605:../Generated_Code/I2C2.c ****     break;
 1409              		.loc 1 605 0
 1410 00cc 10E0     		b	.L66
 1411              	.L64:
 606:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_GENERAL_CALL:
 607:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_7 | ADDR_10); /* Clear the 7-bit address flag and 1
 1412              		.loc 1 607 0
 1413 00ce FB68     		ldr	r3, [r7, #12]
 1414 00d0 1B78     		ldrb	r3, [r3]
 1415 00d2 3022     		mov	r2, #48
 1416 00d4 9343     		bic	r3, r2
 1417 00d6 DAB2     		uxtb	r2, r3
 1418 00d8 FB68     		ldr	r3, [r7, #12]
 1419 00da 1A70     		strb	r2, [r3]
 608:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= GENERAL_CALL; /* Set general call mode flag */
 1420              		.loc 1 608 0
 1421 00dc FB68     		ldr	r3, [r7, #12]
 1422 00de 1B78     		ldrb	r3, [r3]
 1423 00e0 0822     		mov	r2, #8
 1424 00e2 1343     		orr	r3, r2
 1425 00e4 DAB2     		uxtb	r2, r3
 1426 00e6 FB68     		ldr	r3, [r7, #12]
 1427 00e8 1A70     		strb	r2, [r3]
 609:../Generated_Code/I2C2.c ****     break;
 1428              		.loc 1 609 0
 1429 00ea 01E0     		b	.L66
 1430              	.L68:
 610:../Generated_Code/I2C2.c ****     default:
 611:../Generated_Code/I2C2.c ****       return ERR_PARAM_ADDRESS_TYPE;   /* If value of address type is invalid, return error */
 1431              		.loc 1 611 0
 1432 00ec 8D23     		mov	r3, #141
 1433 00ee 00E0     		b	.L60
 1434              	.L66:
 612:../Generated_Code/I2C2.c ****   }
 613:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 1435              		.loc 1 613 0
 1436 00f0 0023     		mov	r3, #0
 1437              	.L60:
 614:../Generated_Code/I2C2.c **** }
 1438              		.loc 1 614 0
 1439 00f2 181C     		mov	r0, r3
 1440 00f4 BD46     		mov	sp, r7
 1441 00f6 04B0     		add	sp, sp, #16
 1442              		@ sp needed for prologue
 1443 00f8 80BD     		pop	{r7, pc}
 1444              	.L70:
 1445 00fa C046     		.align	2
 1446              	.L69:
 1447 00fc FF030000 		.word	1023
 1448              		.cfi_endproc
 1449              	.LFE5:
 1451              		.section	.text.I2C2_GetError,"ax",%progbits
 1452              		.align	2
 1453              		.global	I2C2_GetError
 1454              		.code	16
 1455              		.thumb_func
 1457              	I2C2_GetError:
 1458              	.LFB6:
 615:../Generated_Code/I2C2.c **** 
 616:../Generated_Code/I2C2.c **** /*
 617:../Generated_Code/I2C2.c **** ** ===================================================================
 618:../Generated_Code/I2C2.c **** **     Method      :  I2C2_GetError (component I2C_LDD)
 619:../Generated_Code/I2C2.c **** **
 620:../Generated_Code/I2C2.c **** **     Description :
 621:../Generated_Code/I2C2.c **** **         Returns value of error mask, e.g. LDD_I2C_ARBIT_LOST.
 622:../Generated_Code/I2C2.c **** **     Parameters  :
 623:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 624:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 625:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 626:../Generated_Code/I2C2.c **** **       * ErrorMaskPtr    - Pointer to a variable
 627:../Generated_Code/I2C2.c **** **                           where errors value mask will be stored.
 628:../Generated_Code/I2C2.c **** **     Returns     :
 629:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 630:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 631:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 632:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 633:../Generated_Code/I2C2.c **** **                           the active clock configuration
 634:../Generated_Code/I2C2.c **** ** ===================================================================
 635:../Generated_Code/I2C2.c **** */
 636:../Generated_Code/I2C2.c **** LDD_TError I2C2_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TErrorMask *ErrorMaskPtr)
 637:../Generated_Code/I2C2.c **** {
 1459              		.loc 1 637 0
 1460              		.cfi_startproc
 1461 0000 80B5     		push	{r7, lr}
 1462              	.LCFI18:
 1463              		.cfi_def_cfa_offset 8
 1464              		.cfi_offset 7, -8
 1465              		.cfi_offset 14, -4
 1466 0002 84B0     		sub	sp, sp, #16
 1467              	.LCFI19:
 1468              		.cfi_def_cfa_offset 24
 1469 0004 00AF     		add	r7, sp, #0
 1470              	.LCFI20:
 1471              		.cfi_def_cfa_register 7
 1472 0006 7860     		str	r0, [r7, #4]
 1473 0008 3960     		str	r1, [r7]
 638:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1474              		.loc 1 638 0
 1475 000a 7B68     		ldr	r3, [r7, #4]
 1476 000c FB60     		str	r3, [r7, #12]
 639:../Generated_Code/I2C2.c **** 
 640:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 641:../Generated_Code/I2C2.c ****   EnterCritical();
 1477              		.loc 1 641 0
 1478 000e 144B     		ldr	r3, .L75
 1479 0010 1B78     		ldrb	r3, [r3]
 1480 0012 DBB2     		uxtb	r3, r3
 1481 0014 0133     		add	r3, r3, #1
 1482 0016 DBB2     		uxtb	r3, r3
 1483 0018 114A     		ldr	r2, .L75
 1484 001a 191C     		add	r1, r3, #0
 1485 001c 1170     		strb	r1, [r2]
 1486 001e 012B     		cmp	r3, #1
 1487 0020 04D1     		bne	.L72
 1488              		.loc 1 641 0 is_stmt 0
 1489 0022 104B     		ldr	r3, .L75+4
 1490              	@ 641 "../Generated_Code/I2C2.c" 1
 1491 0024 EFF31080 		MRS R0, PRIMASK
 1492 0028 72B6     		CPSID i
 1493 002a 1870     		STRB R0, [r3]
 1494              	@ 0 "" 2
 1495              		.code	16
 1496              	.L72:
 642:../Generated_Code/I2C2.c ****   *ErrorMaskPtr = DeviceDataPrv->ErrorMask; /* Return last value of error mask */
 1497              		.loc 1 642 0 is_stmt 1
 1498 002c FB68     		ldr	r3, [r7, #12]
 1499 002e 5A88     		ldrh	r2, [r3, #2]
 1500 0030 3B68     		ldr	r3, [r7]
 1501 0032 1A80     		strh	r2, [r3]
 643:../Generated_Code/I2C2.c ****   DeviceDataPrv->ErrorMask = 0x00U;
 1502              		.loc 1 643 0
 1503 0034 FB68     		ldr	r3, [r7, #12]
 1504 0036 0022     		mov	r2, #0
 1505 0038 5A80     		strh	r2, [r3, #2]
 644:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 645:../Generated_Code/I2C2.c ****   ExitCritical();
 1506              		.loc 1 645 0
 1507 003a 094B     		ldr	r3, .L75
 1508 003c 1B78     		ldrb	r3, [r3]
 1509 003e DBB2     		uxtb	r3, r3
 1510 0040 013B     		sub	r3, r3, #1
 1511 0042 DBB2     		uxtb	r3, r3
 1512 0044 064A     		ldr	r2, .L75
 1513 0046 191C     		add	r1, r3, #0
 1514 0048 1170     		strb	r1, [r2]
 1515 004a 002B     		cmp	r3, #0
 1516 004c 03D1     		bne	.L73
 1517              		.loc 1 645 0 is_stmt 0
 1518 004e 054B     		ldr	r3, .L75+4
 1519              	@ 645 "../Generated_Code/I2C2.c" 1
 1520 0050 1878     		ldrb r0, [r3]
 1521 0052 80F31088 		msr PRIMASK,r0;
 1522              		
 1523              	@ 0 "" 2
 1524              		.code	16
 1525              	.L73:
 646:../Generated_Code/I2C2.c ****   return ERR_OK;
 1526              		.loc 1 646 0 is_stmt 1
 1527 0056 0023     		mov	r3, #0
 647:../Generated_Code/I2C2.c **** }
 1528              		.loc 1 647 0
 1529 0058 181C     		mov	r0, r3
 1530 005a BD46     		mov	sp, r7
 1531 005c 04B0     		add	sp, sp, #16
 1532              		@ sp needed for prologue
 1533 005e 80BD     		pop	{r7, pc}
 1534              	.L76:
 1535              		.align	2
 1536              	.L75:
 1537 0060 00000000 		.word	SR_lock
 1538 0064 00000000 		.word	SR_reg
 1539              		.cfi_endproc
 1540              	.LFE6:
 1542              		.text
 1543              	.Letext0:
 1544              		.file 2 "C:/Freescale/CW MCU v10.7/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 1545              		.file 3 "D:/15. MyFactory/MC - Microcontroller/HSLU/MC_Uebungen/Freedom_Accel/Generated_Code/IO_Ma
 1546              		.file 4 "D:/15. MyFactory/MC - Microcontroller/HSLU/MC_Uebungen/Freedom_Accel/Generated_Code/PE_LD
 1547              		.file 5 "D:/15. MyFactory/MC - Microcontroller/HSLU/MC_Uebungen/Freedom_Accel/Generated_Code/Cpu.h
DEFINED SYMBOLS
                            *ABS*:00000000 I2C2.c
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:24     .bss.INT_I2C0__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:27     .bss.INT_I2C0__DEFAULT_RTOS_ISRPARAM:00000000 INT_I2C0__DEFAULT_RTOS_ISRPARAM
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:30     .text.I2C2_Interrupt:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:35     .text.I2C2_Interrupt:00000000 I2C2_Interrupt
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:466    .text.I2C2_Interrupt:000002b0 $d
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:472    .text.I2C2_Init:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:477    .text.I2C2_Init:00000000 I2C2_Init
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:642    .text.I2C2_Init:000000f8 $d
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:655    .text.I2C2_Deinit:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:660    .text.I2C2_Deinit:00000000 I2C2_Deinit
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:703    .text.I2C2_Deinit:00000030 $d
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:711    .text.I2C2_MasterSendBlock:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:716    .text.I2C2_MasterSendBlock:00000000 I2C2_MasterSendBlock
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:981    .text.I2C2_MasterSendBlock:00000184 $d
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:988    .text.I2C2_MasterReceiveBlock:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:993    .text.I2C2_MasterReceiveBlock:00000000 I2C2_MasterReceiveBlock
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:1260   .text.I2C2_MasterReceiveBlock:00000184 $d
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:1267   .text.I2C2_SelectSlaveDevice:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:1272   .text.I2C2_SelectSlaveDevice:00000000 I2C2_SelectSlaveDevice
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:1447   .text.I2C2_SelectSlaveDevice:000000fc $d
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:1452   .text.I2C2_GetError:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:1457   .text.I2C2_GetError:00000000 I2C2_GetError
C:\Users\burak\AppData\Local\Temp\ccrntGDQ.s:1537   .text.I2C2_GetError:00000060 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
I2C2_OnMasterBlockSent
I2C2_OnMasterBlockReceived
I2C2_OnError
PE_LDD_DeviceDataList
SR_lock
SR_reg
